/* 
 * Copyright 2017 Nancy Green
 * This file is part of AVIZE.
 *
 * AVIZE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AVIZE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AVIZE.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.uncg.save.argumentviewtree;

import static com.uncg.save.argumentviewtree.ArgumentNode.PADDING;
import static com.uncg.save.argumentviewtree.ArgumentNode.PREMISE_HEIGHT;
import com.uncg.save.controllers.ArgumentCertaintyPaneController;
import com.uncg.save.controllers.CQPaneController;
import com.uncg.save.controllers.ChainPaneController;
import com.uncg.save.controllers.ChainPropositionChoice;
import com.uncg.save.controllers.ChainTwoPropWarningPaneController;
import com.uncg.save.controllers.ConclusionPaneController;
import com.uncg.save.controllers.CounterArgumentPaneController;
import com.uncg.save.controllers.MultiArgChainPaneController;
import com.uncg.save.controllers.MultiArgConclusionPaneController;
import com.uncg.save.controllers.MultiArgSubConclusionPaneController;
import com.uncg.save.controllers.ConstructionAreaController;
import com.uncg.save.controllers.PremisePaneController;
import com.uncg.save.models.ArgumentModel;
import com.uncg.save.util.LayoutUtils;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.logging.Level;
import java.util.logging.Logger;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Modality;
import javafx.stage.Stage;
import static com.uncg.save.argumentviewtree.ArgumentNode.PREMISE_WIDTH;
import com.uncg.save.controllers.CQArgumentPaneController;
import com.uncg.save.controllers.CounterPropositionPaneController;
import com.uncg.save.models.CounterArgumentModel;
import com.uncg.save.models.PremiseModel;
import java.util.LinkedHashSet;
import java.util.Queue;
import java.util.Set;

/**
 * ArgumentViewTree class provides an entrance to an argument view tree via
 * root. It also defines methods used in the construction, deletion, and
 * alteration of argument view trees.
 *
 * TODO: this class needs major refactoring to remove repeated code and
 * make the class more focused 
 */
public class ArgumentViewTree {

    // unique string id. Generated by getting string representation of
    // getHash() method of this tree object
    private String treeID;

    private ConclusionNode root;

    // collison matrices used to detect collision between view elements
    List<List<ArgumentNode>> paneMatrix;
    List<List<ArgumentNode>> nexusMatrix;

    // Pane that represents the constructionArea that this tree will be drawn on
    private final Pane canvas;
    private final ConstructionAreaController canvasControl;

    /**
     * Constructs new ArgumentViewTree and associates it with a specific pane
     * that will contain it. Starts with a null root.
     *
     * @param pane Pane
     */
    public ArgumentViewTree(Pane pane, ConstructionAreaController control) {
        canvas = pane;
        canvasControl = control;
        root = null;
        paneMatrix = new LinkedList<>();
        nexusMatrix = new LinkedList<>();
    }

    /*
    Getters/setters
     */
    public ConclusionNode getRoot() {
        return root;
    }

    public String getTreeID() {
        return treeID;
    }

    public void setTreeID(String id) {
        treeID = id;
    }

    public List<List<ArgumentNode>> getPaneMatrix() {
        return this.paneMatrix;
    }

    public List<List<ArgumentNode>> getNexusMatrix() {
        return this.nexusMatrix;
    }

    /**
     * Adds a new root argument to a tree. This should be called when a new
     * argument is to be generated from a scheme.
     *
     * @param argument ArgumentModel. Backing model for the root argument
     * @param x double. X coordinate value specifying where the tree will be
     * generated.
     * @param y double. Y coordinate value specifying where the tree will be
     * generated.
     */
    public void addRootArgument(ArgumentModel argument, double x, double y) {
        try {
            Point2D localCoords = LayoutUtils.getLocalCoords(canvas, x, y);
            root = createConclusionView(argument, localCoords);
            canvas.getChildren().add(root.getView());
            List<ArgumentNode> rootPaneList = new ArrayList<>();
            rootPaneList.add(root);
            paneMatrix.add(rootPaneList);

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(argument.getConclusion(), root);
            root.addAsChild(certaintyBox);
            certaintyBox.setParent(root);
            canvas.getChildren().add(certaintyBox.getView());

            ArgumentNode connector
                    = createConclusionConnector(root.getView());
            root.addAsChild(connector);
            connector.setParent(root);
            canvas.getChildren().add(connector.getView());

            ArgumentNode schemeLabel
                    = createSchemeLabel(argument, root.getView());
            root.addAsChild(schemeLabel);
            schemeLabel.setParent(root);
            canvas.getChildren().add(schemeLabel.getView());

            ArgumentNode nexus
                    = createNexus(
                            argument.getSchemeNumPremises(),
                            connector.getView()
                    );
            connector.addAsChild(nexus);
            nexus.setParent(connector);
            canvas.getChildren().add(nexus.getView());
            List<ArgumentNode> rootNexusList = new ArrayList<>();
            rootNexusList.add(nexus);
            nexusMatrix.add(rootNexusList);

            int numPremises = argument.getSchemeNumPremises();
            List<ArgumentNode> premiseNodes = new ArrayList<>();
            for (int i = 0; i < numPremises; i++) {
                ArgumentNode premiseConnect
                        = createPremiseConnection(nexus.getView(), i);
                nexus.addAsChild(premiseConnect);
                premiseConnect.setParent(nexus);
                canvas.getChildren().add(premiseConnect.getView());

                ArgumentNode premiseBox = createPremiseView(
                        argument,
                        premiseConnect.getView(),
                        i
                );
                ArgumentNode certaintyBoxP
                        = createArgumentCertaintyBox(argument, (PremiseNode) premiseBox);
                premiseBox.addAsChild(certaintyBoxP);
                certaintyBoxP.setParent(premiseBox);
                canvas.getChildren().add(certaintyBoxP.getView());
                premiseConnect.addAsChild(premiseBox);
                premiseBox.setParent(premiseConnect);
                canvas.getChildren().add(premiseBox.getView());

                premiseNodes.add(premiseBox);
            }
            paneMatrix.add(premiseNodes);
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Creates a new conclusion pane to be drawn on the tree
     *
     * @param arg ArgumentModel. Backing model for argument
     * @param x double. X coordinate value specifying where the tree will be
     * generated.
     * @param y double. Y coordinate value specifying where the tree will be
     * generated.
     * @return ArgumentNode to be added to tree structure
     * @throws IOException in case of FXML loading failure
     */
    private ConclusionNode createConclusionView(
            ArgumentModel arg, Point2D localCoords) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/ConclusionPane.fxml"));
        Pane conclusionPane = loader.load();
        ConclusionPaneController conclusionControl
                = loader.<ConclusionPaneController>getController();
        conclusionControl.addConclusionArgumentModel(arg);
        conclusionControl.setArgumentViewTree(this);
        conclusionControl.setParentControl(canvasControl);
        Label lbl = createLabel();
        lbl.setText(arg.getSchemeConclusion());
        conclusionControl.setSchemeLabel(lbl);
        LayoutUtils.setChildLayout(conclusionPane, localCoords);

        return new ConclusionNode(conclusionPane, conclusionControl);
    }

    private ArgumentNode createArgumentCertaintyBox(
            PremiseModel controllingModel, ConclusionNode parent) throws IOException {
        FXMLLoader loader = new FXMLLoader(
                getClass().getResource("/fxml/ArgumentCertaintyPane.fxml")
        );
        Pane certPane = loader.load();
        ArgumentCertaintyPaneController certControl
                = loader.<ArgumentCertaintyPaneController>getController();
        parent.getControl().setCertaintyController(certControl);

        canvas.layout();
        Bounds bounds = parent.getView().getBoundsInParent();
        Point2D targetCoords = new Point2D(bounds.getMaxX() - 15, bounds.getMaxY());
        certControl.setControllingModel(controllingModel);
        return new ArgumentCertaintyNode(certPane, certControl, targetCoords);
    }

    private ArgumentNode createArgumentCertaintyBox(
            ArgumentModel argument, PremiseNode parent) throws IOException {
        FXMLLoader loader = new FXMLLoader(
                getClass().getResource("/fxml/ArgumentCertaintyPane.fxml")
        );
        Pane certPane = loader.load();
        ArgumentCertaintyPaneController certControl
                = loader.<ArgumentCertaintyPaneController>getController();
        parent.getControl().setCertaintyController(certControl);

        canvas.layout();
        Bounds bounds = parent.getView().getBoundsInParent();
        Point2D targetCoords = new Point2D(bounds.getMaxX() - 15, bounds.getMaxY());
        certControl.setControllingModel(argument.getConclusion());
        return new ArgumentCertaintyNode(certPane, certControl, targetCoords);
    }

    /**
     * Creates a new Node that connects the conclusion pane to the premise
     * structure. Its layout is determine in relation to the layout of its
     * parent view
     *
     * @param parentView Node. Parent conclusion pane of this connector
     * @return ArgumentNode to be added to the tree structure
     */
    private ArgumentNode createConclusionConnector(Node parentView) {
        Point2D layout = getRelativeLayout(parentView);
        ConclusionConnectionNode connector
                = new ConclusionConnectionNode(layout);

        return connector;
    }

    private ArgumentNode createSchemeLabel(
            ArgumentModel argument, Node parentView) {
        Point2D layout = getRelativeLayout(parentView);
        ArgumentNode schemeLabel = new ArgumentSchemeLabel(argument, layout, this, canvas);

        return schemeLabel;
    }

    /**
     * Creates a "premise nexus" the horizontal line that graphically joins all
     * of the premises in an argument in the argument view tree
     *
     * @param arg ArgumentModel. Backing model for the argument associated with
     * this part of the tree
     * @param parentView Node. Parent JavaFX node of this node.
     * @return ArgumentNode to be added to the tree structure
     */
    private ArgumentNode createNexus(int numPremises, Node parentView) {
        Point2D layout = getRelativeLayout(parentView);
        PremiseNexusNode nexus
                = new PremiseNexusNode(numPremises, layout);

        return nexus;
    }

    /**
     * Creates the vertical lines that connect premise views to the premise
     * nexus. Their position is determined relative to their parent premise
     * nexus and are also offset according to which premise number they are\
     * associated with.
     *
     * @param parentView Node. JavaFX parent of this view structure. Should be a
     * view contained in a PremiseNexus
     * @param premiseNumber int. Number representing the premise position.
     * @return ArgumentNode meant to be added to the tree structure
     */
    private ArgumentNode createPremiseConnection(
            Node parentView, int premiseNumber) {
        Point2D layout = getRelativeLayout(parentView);
        Point2D adjustedLayout = new Point2D(
                layout.getX() - parentView.getBoundsInParent().getWidth() / 2,
                layout.getY()
        );
        PremiseConnectionNode premiseConnection
                = new PremiseConnectionNode(premiseNumber, adjustedLayout);

        return premiseConnection;
    }

    private ArgumentNode createMultiArgPremiseConnection(
            Node parentView, int premiseNumber) {
        Point2D layout = getRelativeLayout(parentView);
        Point2D adjustedLayout = new Point2D(
                layout.getX() - parentView.getBoundsInParent().getWidth() / 2,
                layout.getY()
        );
        MultiArgPremiseConnectionNode multiArgPremiseConnection
                = new MultiArgPremiseConnectionNode(
                        premiseNumber, adjustedLayout
                );

        return multiArgPremiseConnection;
    }

    /**
     * Creates a premise pane whose position is determined relative to its
     * parent PremiseConnectionNode.
     *
     * @param arg ArgumentModel. Backing argument model this premise is a part
     * of
     * @param parentView Node. JavaFX Node parent of this view structure. Should
     * be a view contained in a PremiseConnectionNode.
     * @param premiseNumber int. Number representing the prosition of this
     * premise within its associated argument.
     * @return ArgumnentMode meant to be added to the tree structure
     * @throws IOException in case of FXML load failure
     */
    private ArgumentNode createPremiseView(
            ArgumentModel arg, Node parentView, int premiseNumber) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/PremisePane.fxml"));
        Pane premisePane = loader.load();
        PremisePaneController premiseControl
                = loader.<PremisePaneController>getController();
        premiseControl.setPosition(premiseNumber);
        premiseControl.setArgumentViewTree(this);
        premiseControl.setArgumentModel(arg);
        premiseControl.setParentControl(canvasControl);
        Label lbl = createLabel();
        lbl.setText(arg.getSchemePremise(premiseNumber));
        premiseControl.setSchemeLabel(lbl);
        Point2D layout = getRelativeLayout(parentView);
        Point2D adjustedLayout = new Point2D(
                (int) (layout.getX() - PREMISE_WIDTH / 2),
                (int) layout.getY()
        );

        LayoutUtils.setChildLayout(premisePane, adjustedLayout);

        return new PremiseNode(premisePane, premiseControl);
    }

    /**
     * Creates a new pane and ArgumentNode for the conclusion to multiple
     * arguments that share the same conclusion. Uses the conclusion
     * proposition.
     *
     * @param parentNode ArgumentNode parent of the created node
     * @param conclusionControl
     * @param premiseControl
     * @return
     * @throws IOException
     */
    private ArgumentNode createMultiArgChainViewConclusion(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            PremisePaneController premiseControl)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/MultiArgChainPane.fxml"));
        Pane chainPane = loader.load();
        MultiArgChainPaneController chainControl
                = loader.<MultiArgChainPaneController>getController();
        for (ArgumentModel arg
                : conclusionControl.getConclusionArgumentModelList()) {
            chainControl.addConclusionArgumentModel(arg);
        }

        chainControl.addPremiseArgument(premiseControl.getArgument());
        chainControl.setArgumentViewTree(this);
        chainControl.setParentControl(canvasControl);
        chainControl.setPosition(premiseControl.getPosition());

        chainControl.setPropositionModel(
                conclusionControl
                        .getConclusionArgumentModel()
                        .getConclusion()
                        .getProposition()
        );

        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout = new Point2D(
                (int) (layout.getX() - PREMISE_WIDTH / 2),
                (int) layout.getY()
        );

        LayoutUtils.setChildLayout(chainPane, adjustedLayout);
        return new ChainNode(chainPane, chainControl);
    }

    /**
     * Creates a new pane and ArgumentNode for the conclusion to multiple
     * arguments that share the same conclusion. Uses the premise proposition.
     *
     * @param parentNode
     * @param conclusionControl
     * @param premiseControl
     * @return
     * @throws IOException
     */
    private ArgumentNode createMultiArgChainViewPremise(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            PremisePaneController premiseControl)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/MultiArgChainPane.fxml"));
        Pane chainPane = loader.load();
        MultiArgChainPaneController chainControl
                = loader.<MultiArgChainPaneController>getController();

        for (ArgumentModel arg
                : conclusionControl.getConclusionArgumentModelList()) {
            chainControl.addConclusionArgumentModel(arg);
        }

        chainControl.addPremiseArgument(premiseControl.getArgument());
        chainControl.setArgumentViewTree(this);
        chainControl.setParentControl(canvasControl);

        chainControl.setPosition(premiseControl.getPosition());

        chainControl.setPropositionModel(
                premiseControl.getProposition()
        );

        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout = new Point2D(
                (int) (layout.getX() - PREMISE_WIDTH / 2),
                (int) layout.getY()
        );

        LayoutUtils.setChildLayout(chainPane, adjustedLayout);
        return new ChainNode(chainPane, chainControl);
    }

    /**
     * Creates a ChainPane as part of a merger procedure, inheriting the
     * properties and fields of the conclusion being merged in to this tree
     *
     * @param parentNode ArgumentNode parent of the point of merger
     * @param conclusionControl ConclusionPaneController controller of the
     * conclusion being merged in
     * @param premiseControl PremisePaneController controller of the premise
     * that is being merged into
     * @return ArgumentNode the created Chain Pane
     * @throws IOException
     */
    private ArgumentNode createChainViewConclusion(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            PremisePaneController premiseControl)
            throws IOException {
        ChainPaneController chainControl = generateChainNode();

        chainControl.addConclusionArgumentModel(
                conclusionControl.getConclusionArgumentModel()
        );
        chainControl.addPremiseArgument(premiseControl.getArgument());
        chainControl.setArgumentViewTree(this);
        chainControl.setParentControl(canvasControl);
        chainControl.setCertaintyController(
                conclusionControl.getCertaintyController()
        );
        chainControl.setPosition(premiseControl.getPosition());
        chainControl.setPropositionModel(
                conclusionControl.getConclusionArgumentModel().getConclusion().getProposition()
        );
        chainControl.checkHasProp();

        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout = new Point2D(
                (int) (layout.getX() - PREMISE_WIDTH / 2),
                (int) layout.getY()
        );

        LayoutUtils.setChildLayout(chainControl.getMainPane(), adjustedLayout);
        return new ChainNode(chainControl.getMainPane(), chainControl);
    }

    /**
     * Creates a ChainPane as part of a merger procedure, inheriting the
     * properties and fields of the premise that is being merged into
     *
     * @param parentNode ArgumentNode parent of the point of merger
     * @param conclusionControl ConclusionPaneController controller of the
     * conclusion being merged in
     * @param premiseControl PremisePaneController controller of the premise
     * that is being merged into
     * @return ArgumentNode the created Chain Pane
     * @throws IOException
     */
    private ArgumentNode createChainViewPremise(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            PremisePaneController premiseControl)
            throws IOException {
        ChainPaneController chainControl = generateChainNode();

        chainControl.setArgumentViewTree(this);
        chainControl.addConclusionArgumentModel(
                conclusionControl.getConclusionArgumentModel()
        );
        chainControl.addPremiseArgument(premiseControl.getArgument());
        chainControl.setParentControl(canvasControl);
        chainControl.setCertaintyController(
                premiseControl.getCertaintyController()
        );
        chainControl.setPosition(premiseControl.getPosition());
        chainControl.setPropositionModel(
                premiseControl.getProposition()
        );
        chainControl.checkHasProp();

        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout = new Point2D(
                (int) (layout.getX() - PREMISE_WIDTH / 2),
                (int) layout.getY()
        );

        LayoutUtils.setChildLayout(chainControl.getMainPane(), adjustedLayout);
        return new ChainNode(chainControl.getMainPane(), chainControl);
    }

    /**
     * Creates a Chain Pane and its associated node
     *
     * @return ChainPaneController the controller of the chain pane
     * @throws IOException
     */
    private ChainPaneController generateChainNode() throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/ChainPane.fxml"));
        Pane chainPane = loader.load();
        ChainPaneController chainControl
                = loader.<ChainPaneController>getController();
        return chainControl;
    }

    /**
     * Creates a new conclusion for multiple arguments that share the same
     * conclusion when a multi-arg structure is being detached
     *
     * @param multiChainNode
     * @param multiChainControl
     * @return
     * @throws IOException
     */
    private ConclusionNode createNewMultiArgConclusion(
            ArgumentNode multiChainNode,
            MultiArgChainPaneController multiChainControl)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/MultiArgConclusionPane.fxml"));
        Pane multiArgPane = loader.load();
        MultiArgConclusionPaneController multiArgControl
                = loader.<MultiArgConclusionPaneController>getController();

        for (ArgumentModel arg
                : multiChainControl.getConclusionArgumentModelList()) {
            multiArgControl.addConclusionArgumentModel(arg);
        }
        multiArgControl.setParentControl(canvasControl);

        if (multiChainControl.getProposition() != null) {
            multiArgControl.setPropositionModel(
                    multiChainControl.getProposition()
            );
        }

        Point2D adjustedLayout = new Point2D(
                (int) multiChainNode.getView().getBoundsInParent().getMinX(),
                (int) multiChainNode.getView().getBoundsInParent().getMinY()
        );

        LayoutUtils.setChildLayout(multiArgPane, adjustedLayout);
        return new ConclusionNode(multiArgPane, multiArgControl);
    }

    /**
     * Method creates the circular CQ icon
     *
     * @param parentNode ArgumentNode parent of the icon
     * @return CQIcon ArgumentNode
     * @throws IOException
     */
    private CQIcon createCQIcon(ArgumentNode parentNode) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/CriticalIconFXML.fxml"));
        Pane cqIcon = loader.load();

        Point2D targetCoords = new Point2D(
                parentNode.getView().getBoundsInParent().getMinX() - 100,
                parentNode.getView().getBoundsInParent().getMinY() - 50
        );
        LayoutUtils.setChildLayout(cqIcon, targetCoords);
        return new CQIcon(cqIcon);
    }

    /**
     * Creates a CQPane to contain an answer to a counter argument
     *
     * @param arg ArgumentModel the response to the CQ
     * @param parentArg ArgumentModel that poses the CQ
     * @param parent ArgumentNode parent node in the tree structure
     * @return ArgumentNode the ArgumentNode
     * @throws IOException
     */
    private ArgumentNode createCQView(
            ArgumentModel arg,
            ArgumentModel parentArg,
            ArgumentNode parent
    ) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/CQPane.fxml"));
        Pane cqPane = loader.load();
        CQPaneController cqControl
                = loader.<CQPaneController>getController();
        cqControl.setArgumentViewTree(this);
        cqControl.setArgumentModel(arg);
        cqControl.setParentArgument(parentArg);
        cqControl.setParentControl(canvasControl);
        cqControl.setConnector(parent);
        Point2D layout = getRelativeLayout(parent.getView());
        Point2D adjustedLayout
                = new Point2D(
                        (int) layout.getX() + parent.getWidth() - 163,
                        (int) layout.getY()
                );
        LayoutUtils.setChildLayout(cqPane, adjustedLayout);
        return new CQNode(cqPane, cqControl);
    }

    private ArgumentNode createCQConnection(
            ArgumentModel arg,
            ArgumentNode parentNode) {
        ArgumentNode targetNexus = findNextNexus(parentNode);
        Point2D parentLayout = getRelativeLayout(parentNode.getView());
        Point2D nexusLayout = getRelativeLayout(targetNexus.getView());
        Point2D adjustedLayout = new Point2D(
                parentLayout.getX(),
                nexusLayout.getY() - 60
        );
        CQConnectionNode cqConnection
                = new CQConnectionNode(adjustedLayout);

        return cqConnection;
    }

    /**
     * Method creates an pane using values from the conclusion of the merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param cqControl
     * @return
     * @throws IOException
     */
    private ArgumentNode createCQArgPaneConclusion(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            CQPaneController cqControl
    ) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/CQArgumentPane.fxml"));
        Pane cqArgPane = loader.load();
        CQArgumentPaneController cqArgControl
                = loader.<CQArgumentPaneController>getController();
        cqArgControl.setArgumentModel(
                conclusionControl.getConclusionArgumentModel()
        );
        cqArgControl.setParentArgument(cqControl.getParentArgument());
        cqArgControl.setArgumentViewTree(this);
        cqArgControl.setParentControl(canvasControl);
        cqArgControl.setCertaintyController(
                conclusionControl.getCertaintyController()
        );
        if (conclusionControl.getConclusionArgumentModel().getConclusion() != null) {
            System.out.println("setting prop model");
            System.out.println(conclusionControl.getConclusionArgumentModel().getConclusion().getProposition());
            cqArgControl.setPropositionModel(
                    conclusionControl.getConclusionArgumentModel().getConclusion().getProposition()
            );
        }
        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout
                = new Point2D(
                        (int) layout.getX()
                        + cqControl.getConnector().getWidth() - 163,
                        (int) layout.getY()
                );
        LayoutUtils.setChildLayout(cqArgPane, adjustedLayout);
        return new CQArgumentNode(cqArgPane, cqArgControl);
    }

    /**
     * Creates a CQ pane with the values from the premise side of the merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param cqControl
     * @return
     * @throws IOException
     */
    private ArgumentNode createCQArgPanePremise(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            CQPaneController cqControl
    ) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/CQArgumentPane.fxml"));
        Pane cqArgPane = loader.load();
        CQArgumentPaneController cqArgControl
                = loader.<CQArgumentPaneController>getController();
        cqArgControl.setArgumentModel(
                conclusionControl.getConclusionArgumentModel()
        );
        cqArgControl.setParentArgument(cqControl.getParentArgument());
        cqArgControl.setArgumentViewTree(this);
        cqArgControl.setParentControl(canvasControl);
        cqArgControl.setCertaintyController(
                cqControl.getCertaintyController()
        );
        cqArgControl.setPropositionModel(
                cqControl.getProposition()
        );

        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout = new Point2D((int) layout.getX() + cqControl.getConnector().getWidth() - 163, (int) layout.getY());

        LayoutUtils.setChildLayout(cqArgPane, adjustedLayout);

        return new CQArgumentNode(cqArgPane, cqArgControl);
    }

    /**
     * Creates the shield Icon for counter arguement structure
     *
     * @param parent ArgumentNode parent of the icon
     * @return
     * @throws IOException
     */
    private ArgumentNode createCounterIcon(ArgumentNode parent)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/CounterShieldFXML.fxml"));
        Pane counterIcon = loader.load();

        Point2D targetCoords = new Point2D(
                parent.getView().getBoundsInParent().getMaxX(),
                parent.getView().getBoundsInParent().getMinY() - 73
        );
        LayoutUtils.setChildLayout(counterIcon, targetCoords);
        return new CounterIcon(counterIcon);
    }

    /**
     * Creates a counter proposition view. Counter proposition views are counter
     * arguments that do not have a proper argument attached to them
     *
     * @param parentModelList
     * @param counterArg
     * @param parent
     * @return
     * @throws IOException
     */
    private ArgumentNode createCounterPropositionView(
            List<PremiseModel> parentModelList,
            CounterArgumentModel counterArg,
            ArgumentNode parent) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/CounterPropositionPane.fxml"));
        Pane counterPane = loader.load();
        CounterPropositionPaneController counterControl
                = loader.<CounterPropositionPaneController>getController();
        counterControl.setArgumentViewTree(this);
        counterControl.setArgumentModel(counterArg);
        counterControl.setParentModelList(parentModelList);
        counterControl.setParentControl(canvasControl);
        Point2D layout = getRelativeLayout(parent.getView());

        Point2D adjustedLayout;
        adjustedLayout
                = new Point2D(
                        (int) layout.getX() - (PREMISE_WIDTH / 2),
                        (int) layout.getY()
                );

        LayoutUtils.setChildLayout(counterPane, adjustedLayout);
        return new CounterPropositionNode(counterPane, counterControl);
    }

    /**
     * Creates the connector between an argument and its counter arguments
     *
     * @param parentView
     * @return
     */
    private ArgumentNode createCounterArgumentConnection(Node parentView) {
        Point2D adjustedLayout;
        adjustedLayout = new Point2D(
                parentView.getBoundsInParent().getMinX(),
                parentView.getBoundsInParent().getMinY()
        );

        CounterArgumentConnectionNode counterConnection
                = new CounterArgumentConnectionNode(adjustedLayout);

        return counterConnection;
    }

    /**
     * Creates a counter argument pane using the values of the conclusion side
     * of a merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param counterControl
     * @return
     * @throws IOException
     */
    private ArgumentNode createCounterArgumentViewConclusion(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            CounterPropositionPaneController counterControl)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/CounterArgumentPane.fxml"));
        Pane counterArgumentPane = loader.load();
        CounterArgumentPaneController counterArgumentControl
                = loader.<CounterArgumentPaneController>getController();

        /*
        remove the proposition counter argument from the parent argument's
        counter arg list, replace it with the new merged conclusion's argument
         */
        // get variable's set up for readability
        List<PremiseModel> parentModelList
                = counterControl.getParentModelList();
        List<List<CounterArgumentModel>> parentCounterArgLists
                = new ArrayList<>();

        for (PremiseModel model : parentModelList) {
            parentCounterArgLists.add(model.getCounterArgumentList());
        }

        ArgumentModel propCounterArg = counterControl.getArgument();
        ArgumentModel conclusionArgument
                = conclusionControl.getConclusionArgumentModel();
        CounterArgumentModel newCounterArgument
                = new CounterArgumentModel(conclusionArgument);

        for (List<CounterArgumentModel> counterArgList
                : parentCounterArgLists) {
            int indexOfPropCounter = counterArgList.indexOf(propCounterArg);

            // the actual swap
            counterArgList.remove(propCounterArg);
            counterArgList.add(indexOfPropCounter, newCounterArgument);
        }

        /*
        assign the fields for the created counter argument pane
         */
        counterArgumentControl.setArgumentModel(newCounterArgument);
        counterArgumentControl.setParentModelList(parentModelList);
        counterArgumentControl.setParentControl(canvasControl);
        counterArgumentControl.addProposition(
                conclusionControl.getProposition()
        );
        counterArgumentControl.setArgumentViewTree(this);
        counterArgumentControl.setCertaintyController(
                conclusionControl.getCertaintyController()
        );
        counterArgumentControl.setPosition(counterControl.getPosition());

        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout = new Point2D(
                (int) (layout.getX() - PREMISE_WIDTH / 2),
                (int) layout.getY()
        );
        LayoutUtils.setChildLayout(counterArgumentPane, adjustedLayout);
        return new CounterArgumentNode(counterArgumentPane, counterArgumentControl);
    }

    /**
     * Creates a counter argument pane using the values from the premise side of
     * a merge
     *
     * @param parentNode
     * @param conclusionControl
     * @param counterControl
     * @return
     * @throws IOException
     */
    private ArgumentNode createCounterArgumentViewPremise(
            ArgumentNode parentNode,
            ConclusionPaneController conclusionControl,
            CounterPropositionPaneController counterControl)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/CounterArgumentPane.fxml"));
        Pane counterArgumentPane = loader.load();
        CounterArgumentPaneController counterArgumentControl
                = loader.<CounterArgumentPaneController>getController();

        /*
        remove the proposition counter argument from the parent argument's
        counter arg list, replace it with the new merged conclusion's argument
         */
        // get variable's set up for readability
        List<PremiseModel> parentModelList
                = counterControl.getParentModelList();
        List<List<CounterArgumentModel>> parentCounterArgLists
                = new ArrayList<>();

        for (PremiseModel model : parentModelList) {
            parentCounterArgLists.add(model.getCounterArgumentList());

        }

        ArgumentModel propCounterArg = counterControl.getArgument();

        ArgumentModel conclusionArgument
                = conclusionControl.getConclusionArgumentModel();
        CounterArgumentModel newCounterArgument
                = new CounterArgumentModel(conclusionArgument);

        for (List<CounterArgumentModel> counterArgList
                : parentCounterArgLists) {
            int indexOfPropCounter = counterArgList.indexOf(propCounterArg);
            // the actual swap
            counterArgList.remove(propCounterArg);
            counterArgList.add(indexOfPropCounter, newCounterArgument);
        }
        counterArgumentControl.setArgumentModel(newCounterArgument);
        counterArgumentControl.setParentModelList(parentModelList);
        counterArgumentControl.setParentControl(canvasControl);
        counterArgumentControl.addProposition(
                counterControl.getProposition()
        );
        counterArgumentControl.setArgumentViewTree(this);

        counterArgumentControl.setCertaintyController(
                counterControl.getCertaintyController()
        );
        counterArgumentControl.setPosition(counterControl.getPosition());

        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout = new Point2D(
                (int) (layout.getX() - PREMISE_WIDTH / 2),
                (int) layout.getY()
        );
        LayoutUtils.setChildLayout(counterArgumentPane, adjustedLayout);
        return new CounterArgumentNode(
                counterArgumentPane,
                counterArgumentControl
        );
    }

    /**
     * Creates a view for an individual conclusion in a multiple-arguments
     * sharing the same conclusion structure
     * 
     * @param arg
     * @param parentView
     * @param certaintyControl
     * @param pos
     * @return
     * @throws IOException 
     */
    private ArgumentNode createMultiArgSubView(
            ArgumentModel arg,
            Node parentView,
            ArgumentCertaintyPaneController certaintyControl,
            int pos
    ) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/MultiArgSubConclusionPane.fxml"));
        Pane premisePane = loader.load();
        MultiArgSubConclusionPaneController subConControl
                = loader.<MultiArgSubConclusionPaneController>getController();
        subConControl.setArgumentViewTree(this);
        subConControl.setArgument(arg);
        subConControl.setParentControl(canvasControl);
        subConControl.setCertaintyControl(certaintyControl);

        Point2D layout = getRelativeLayout(parentView);
        Point2D adjustedLayout = new Point2D(
                (int) (layout.getX() - (40 / 2)),
                (int) layout.getY()
        );

        LayoutUtils.setChildLayout(premisePane, adjustedLayout);

        return new MultiArgSubNode(premisePane, subConControl);
    }

    /**
     * Creates a model for multiple arguments sharing the same conclusion
     * 
     * @param parentView
     * @return 
     */
    private ArgumentNode createMultiArgLabel(Node parentView) {
        Point2D layout = getRelativeLayout(parentView);
        ArgumentNode label = new MultipleArgLabel(layout, this, canvas);

        return label;
    }

    /**
     * Creates a pane for the conclusion of multiple arguments sharing the same
     * conclusion with values taken from the conclusion side of a merge
     * 
     * @param mainConNode
     * @param mainConControl
     * @param mergeConControl
     * @return
     * @throws IOException 
     */
    private ConclusionNode createNewMultiArgConclusion(
            ArgumentNode mainConNode,
            ConclusionPaneController mainConControl,
            ConclusionPaneController mergeConControl)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/MultiArgConclusionPane.fxml"));
        Pane multiArgPane = loader.load();
        MultiArgConclusionPaneController multiArgControl
                = loader.<MultiArgConclusionPaneController>getController();

        multiArgControl.setArgumentViewTree(this);
        multiArgControl.addConclusionArgumentModel(mainConControl.getConclusionArgumentModel());
        multiArgControl.addConclusionArgumentModel(mergeConControl.getConclusionArgumentModel());
        multiArgControl.setParentControl(canvasControl);

        multiArgControl.setPropositionModel(
                mainConControl.getProposition()
        );
        Point2D adjustedLayout = new Point2D(
                (int) mainConNode.getView().getBoundsInParent().getMinX(),
                (int) mainConNode.getView().getBoundsInParent().getMinY()
        );

        LayoutUtils.setChildLayout(multiArgPane, adjustedLayout);
        return new ConclusionNode(multiArgPane, multiArgControl);
    }

    private ChainNode createMultiArgChainView(
            ConclusionPaneController conclusionControl,
            ChainPaneController chainControl)
            throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass()
                .getResource("/fxml/MultiArgChainPane.fxml"));
        Pane chainPane = loader.load();
        MultiArgChainPaneController multiChainControl
                = loader.<MultiArgChainPaneController>getController();
        if (chainControl.getCQFlag()) {
            multiChainControl.setCQFlag();
            multiChainControl.setConnector(chainControl.getConnector());
        }
        if (chainControl.getCounterFlag()) {
            multiChainControl.setCounterFlag();
            multiChainControl.setConnector(chainControl.getConnector());
        }
        for (ArgumentModel arg
                : conclusionControl.getConclusionArgumentModelList()) {
            multiChainControl.addConclusionArgumentModel(arg);
        }

        for (ArgumentModel arg
                : chainControl.getConclusionArgumentModelList()) {
            multiChainControl.addConclusionArgumentModel(arg);
        }
        multiChainControl.addPremiseArgument(chainControl.getPremiseArgument());
        multiChainControl.setArgumentViewTree(this);
        multiChainControl.setParentControl(canvasControl);

        multiChainControl.setPosition(chainControl.getPosition());

        multiChainControl.setPropositionModel(
                chainControl.getProposition()
        );

        multiChainControl.getMainPane().setLayoutX(chainControl.getMainPane().getLayoutX());
        multiChainControl.getMainPane().setLayoutY(chainControl.getMainPane().getLayoutY());
        return new ChainNode(chainPane, multiChainControl);
    }

    /**
     * Opens a dialogue window for the user to pick which proposition will be
     * carried over when chaining arguments
     *
     * @return ChainPropositionChoice which is an enum value specifying the
     * users selection
     * @throws IOException
     */
    private ChainPropositionChoice showPropositionChoiceDialogue() throws IOException {
        FXMLLoader loader
                = new FXMLLoader(
                        getClass().getResource(
                                "/fxml/ChainTwoPropWarningPane.fxml"
                        )
                );
        Parent propChoiceBox = loader.load();
        ChainTwoPropWarningPaneController propChoiceControl
                = loader
                        .<ChainTwoPropWarningPaneController>getController();
        Scene scene = new Scene(propChoiceBox);
        Stage stage = new Stage();
        stage.setTitle("Choose proposition");
        stage.setScene(scene);
        stage.initModality(Modality.APPLICATION_MODAL);
        stage.initOwner(canvas.getScene().getWindow());
        stage.showAndWait();
        return propChoiceControl.getUserPropositionChoice();
    }

    /**
     * Calculates the appropriate layout of a Node relative to its parent. This
     * method should return a point that is the the bottom center of a parent
     * view.
     *
     * @param parentView Node. Parent JavaFX Node meant to be used as a
     * reference for calculating the desired Point coordinates
     * @return Point2D coordinates detailing a point at the bottom center of the
     * specified parent Node
     */
    private Point2D getRelativeLayout(Node parentView) {
        canvas.layout();
        Bounds parentBounds = parentView.getBoundsInParent();
        double parentHeight = parentBounds.getHeight();
        double parentWidth = parentBounds.getWidth();

        double targetX = parentBounds.getMinX() + parentWidth / 2;
        double targetY = parentBounds.getMinY() + parentHeight;
        Point2D localCoords = new Point2D(targetX, targetY);
        return localCoords;
    }

    /**
     * Calculates the translation necessary for relocating a node to the
     * specified coordinates. Calls a helper method that recursively iterates
     * through the tree to translate all child nodes
     *
     * @param x double. Destination X coordinate
     * @param y double. Destination Y coordinate
     */
    public void translateTree(double x, double y) {
        double transX = x - root.getView().getLayoutX();
        double transY = y - root.getView().getLayoutY();
        translateNode(root, transX, transY);
    }

    /**
     * Helper method that translates a node by the specified X and Y amounts,
     * then recursively processes all child ArgumentNodes
     *
     * @param node ArgumentNode to be translated
     * @param x double. Translation amount on X plane
     * @param y double. Translation amount on Y plane
     */
    public void translateNode(ArgumentNode node, double x, double y) {
        node.getView().setLayoutX(node.getView().getLayoutX() + x);
        node.getView().setLayoutY(node.getView().getLayoutY() + y);
        node.moveComment(x, y);
        for (ArgumentNode child : node.getChildren()) {
            translateNode(child, x, y);
        }
    }

    /**
     * Method for attaching a subtree to an existing tree.
     *
     * @param newNode ArgumentNode point of connection between the two trees
     * @param oldNode ArgumentNode that is replaced by newNode
     * @param parent ArgumentNode parent of oldNode
     * @param subTree ArgumentViewTree that will be attached
     * @param subTreeID String ID of subtree
     */
    private void attachNewSubTree(
            ArgumentNode newNode,
            ArgumentNode oldNode,
            ArgumentNode parent,
            ArgumentViewTree subTree,
            String subTreeID
    ) {
        newNode.setParent(parent);
        rearrangeChildren(
                parent,
                oldNode,
                newNode,
                subTree
        );
        updateNexusMatrix(newNode, subTree);
        updatePaneMatrix(oldNode, newNode, subTree);
        canvasControl.removeArgumentTree(subTreeID);
    }

    /**
     * Method to delete all comments in an argument view tree
     */
    public void deleteCommentPanes() {
        root.deleteCommentPane();
        deleteCommentPane(root);
    }

    /**
     * Recursive helper method to delete all comments in a tree
     *
     * @param node
     */
    public void deleteCommentPane(ArgumentNode node) {
        node.deleteCommentPane();
        for (ArgumentNode child : node.getChildren()) {
            deleteCommentPane(child);
        }
    }

    /**
     * Recursively goes through an ArgumentViewTree starting at the specified
     * ArgumentNode and sets its ArgumentViewTree reference to this tree
     *
     * @param node ArgumentNode
     */
    private void changeArgTree(ArgumentNode node) {
        node.setArgTree(this);
        for (ArgumentNode child : node.getChildren()) {
            changeArgTree(child);
        }
    }

    private ArgumentNode searchForNode(
            ArgumentNode node, Pane target) {
        if (node.getView().equals(target)) {
            return node;
        }
        ArgumentNode result = null;
        for (int i = 0; result == null && i < node.getChildren().size(); i++) {
            result = searchForNode(
                    node.getChildren().get(i), target
            );
        }
        return result;
    }

    /**
     * Reassigns children/parent relations when merging argument structures.
     *
     * @param targetParent ArgumentNode parent of the target node
     * @param target ArgumentNode point of merger, will be replaced by a new
     * type of node that will link the two argument structures
     * @param chainNode ArgumentNode new argument node meant to link the two
     * argument structures
     * @param mergedTree ArgumentViewTree being merged into this one
     */
    private void rearrangeChildren(
            ArgumentNode targetParent,
            ArgumentNode target,
            ArgumentNode chainNode,
            ArgumentViewTree mergedTree) {
        targetParent.removeChild(target);
        targetParent.addAsChild(chainNode);

        ListIterator<ArgumentNode> targetChildren
                = target.getChildren().listIterator();
        while (targetChildren.hasNext()) {
            ArgumentNode child = targetChildren.next();
            chainNode.addAsChild(child);
            child.setParent(chainNode);
            targetChildren.remove();
        }

        canvas.getChildren().add(chainNode.getView());
        canvas.getChildren().remove(target.getView());

        mergedTree.translateTree(
                chainNode.getView().getLayoutX(),
                chainNode.getView().getLayoutY()
        );

        ArgumentNode mergedTreeRoot = mergedTree.getRoot();
        ListIterator<ArgumentNode> oldTreeChildren
                = mergedTreeRoot.getChildren().listIterator();
        while (oldTreeChildren.hasNext()) {
            ArgumentNode child = oldTreeChildren.next();
            chainNode.addAsChild(child);
            child.setParent(chainNode);
            changeArgTree(child);
            oldTreeChildren.remove();
        }
        canvas.getChildren().remove(mergedTreeRoot.getView());
    }

    /**
     * Check if this tree contains the specified node
     *
     * @param node ArgumentNode being searched for
     * @return boolean
     */
    private boolean containsNode(ArgumentNode node) {
        return containsNode(root, node);
    }

    /**
     * Recursive helper method to traverse the tree searching for target
     * ArgumentNode
     *
     * @param current ArgumentNode being inspected
     * @param target ArgumentNode being searched for
     * @return boolean
     */
    private boolean containsNode(ArgumentNode current, ArgumentNode target) {
        if (current.equals(target)) {
            return true;
        }

        boolean targetFound = false;
        for (int i = 0; !targetFound && i < current.getChildren().size(); i++) {
            targetFound = containsNode(current.getChildren().get(i), target);
        }
        return targetFound;
    }

    /**
     * sets the root of this argument view tree
     *
     * @param root
     */
    private void setRoot(ConclusionNode root) {
        this.root = root;
    }

    /**
     * Method deletes this argument structure and erases it from the gui
     */
    public void deleteArgument() {
        deleteCommentPanes();
        eraseTree(root);
        canvasControl.removeArgumentTree(treeID);
    }

    /**
     * Recursively erases all elements of this tree from the construction area
     *
     * @param node ArgumentNode currently being erased
     */
    private void eraseTree(ArgumentNode node) {
        canvas.getChildren().remove(node.getView());
        ListIterator<ArgumentNode> it = node.getChildren().listIterator();
        while (it.hasNext()) {
            eraseTree(it.next());
        }
    }

    /**
     * Creates a new label
     *
     * @return
     */
    private Label createLabel() {
        Label lbl = new Label();
        lbl.setWrapText(true);
        lbl.setMaxWidth(305);
        lbl.setTextFill(Color.WHITE);
        lbl.setLayoutX(10);
        lbl.setLayoutY(5);
        lbl.setFont(new Font("System Regular", 18));
        return lbl;
    }

    // Methods for handleing tree mergers such as adding sub arguments
    //--------------------------------------------------------------------------
    /**
     * Method for chaining arguments. Merges arguments by making one a
     * sub-argument of the other
     *
     * @param futureChildID String ID of the tree that will become a
     * sub-arguments
     * @param premiseControl point of merger in the "main" tree
     */
    public void mergeTree(String futureChildID,
            PremisePaneController premiseControl) {
        ArgumentViewTree mergedTree = canvasControl.getArgTree(futureChildID);
        mergedTree.deleteCommentPanes();
        ArgumentNode target
                = searchForNode(root, premiseControl.getMainPane());
        ArgumentNode targetParent = target.getParent();
        ArgumentNode chainNode = null;
        deleteCommentPane(target);
        try {
            if (premiseControl.getProposition() != null
                    || mergedTree.getRoot()
                            .getControl().getProposition() != null) {
                if (premiseControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null) {
                    ChainPropositionChoice userChoice
                            = showPropositionChoiceDialogue();
                    if (userChoice == ChainPropositionChoice.CONCLUSION) {
                        if (mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController) {
                            chainNode = createMultiArgChainViewConclusion(
                                    targetParent,
                                    mergedTree.getRoot().getControl(),
                                    premiseControl
                            );
                        } else {
                            chainNode = createChainViewConclusion(
                                    targetParent,
                                    mergedTree.getRoot().getControl(),
                                    premiseControl
                            );
                        }
                    } else if (userChoice == ChainPropositionChoice.PREMISE) {
                        if (mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController) {
                            chainNode = createMultiArgChainViewPremise(
                                    targetParent,
                                    mergedTree.getRoot().getControl(),
                                    premiseControl
                            );
                        } else {
                            chainNode = createChainViewPremise(
                                    targetParent,
                                    mergedTree.getRoot().getControl(),
                                    premiseControl
                            );
                        }
                    } else {
                        System.out.println("canceled with no merge");;
                    }
                } else if (premiseControl.getProposition() == null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null) {
                    if (mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController) {
                        chainNode = createMultiArgChainViewConclusion(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                premiseControl
                        );
                    } else {
                        chainNode = createChainViewConclusion(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                premiseControl
                        );
                    }
                } else if (premiseControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() == null) {
                    if (mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController) {
                        chainNode = createMultiArgChainViewPremise(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                premiseControl
                        );
                    } else {
                        chainNode = createChainViewPremise(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                premiseControl
                        );
                    }
                }
                attachNewSubTree(
                        chainNode,
                        target,
                        targetParent,
                        mergedTree,
                        futureChildID
                );
                canvasControl.removeArgumentTree(futureChildID);
                collisionAdjustment();
                canvasControl.constructionAreaSizeCheck();
            }
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Method for chaining an argument to a counter proposition pane
     *
     * @param futureChildID
     * @param counterControl
     */
    public void mergeTree(String futureChildID,
            CounterPropositionPaneController counterControl) {
        ArgumentNode target
                = searchForNode(root, counterControl.getMainPane());
        ArgumentNode targetParent = target.getParent();
        ArgumentViewTree mergedTree = canvasControl.getArgTree(futureChildID);
        ArgumentNode counterArgumentNode = null;
        mergedTree.deleteCommentPanes();
        deleteCommentPane(target);
        try {
            if (counterControl.getProposition() != null
                    || mergedTree.getRoot()
                            .getControl().getProposition() != null) {
                if (counterControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null) {
                    ChainPropositionChoice userChoice
                            = showPropositionChoiceDialogue();
                    if (userChoice == ChainPropositionChoice.CONCLUSION) {
                        counterArgumentNode = createCounterArgumentViewConclusion(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                counterControl
                        );
                    } else if (userChoice == ChainPropositionChoice.PREMISE) {
                        counterArgumentNode = createCounterArgumentViewPremise(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                counterControl
                        );
                    } else {
                        System.out.println("canceled with no merge");;
                    }
                } else if (counterControl.getProposition() == null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null) {
                    counterArgumentNode = createCounterArgumentViewConclusion(
                            targetParent,
                            mergedTree.getRoot().getControl(),
                            counterControl
                    );
                } else if (counterControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() == null) {
                    counterArgumentNode = createCounterArgumentViewPremise(
                            targetParent,
                            mergedTree.getRoot().getControl(),
                            counterControl
                    );;
                }
                attachNewSubTree(
                        counterArgumentNode,
                        target,
                        targetParent,
                        mergedTree,
                        futureChildID
                );
                canvasControl.removeArgumentTree(futureChildID);
                collisionAdjustment();
                canvasControl.constructionAreaSizeCheck();
            }
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Method for chaining arguments to a CQPane controller
     *
     * @param futureChildID
     * @param cqControl
     */
    public void mergeTree(String futureChildID,
            CQPaneController cqControl) {
        ArgumentNode target
                = searchForNode(root, cqControl.getMainPane());
        ArgumentNode targetParent = target.getParent();
        ArgumentViewTree mergedTree = canvasControl.getArgTree(futureChildID);
        ArgumentNode cqArgNode = null;
        mergedTree.deleteCommentPanes();
        deleteCommentPane(target);
        try {
            if (cqControl.getProposition() != null
                    || mergedTree.getRoot()
                            .getControl().getProposition() != null) {
                if (cqControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null) {
                    ChainPropositionChoice userChoice
                            = showPropositionChoiceDialogue();
                    if (userChoice == ChainPropositionChoice.CONCLUSION) {
                        cqArgNode = createCQArgPaneConclusion(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                cqControl
                        );
                    } else if (userChoice == ChainPropositionChoice.PREMISE) {
                        cqArgNode = createCQArgPanePremise(
                                targetParent,
                                mergedTree.getRoot().getControl(),
                                cqControl
                        );
                    } else {
                        System.out.println("canceled with no merge");;
                    }
                } else if (cqControl.getProposition() == null
                        && mergedTree.getRoot()
                                .getControl().getProposition() != null) {
                    cqArgNode = createCQArgPaneConclusion(
                            targetParent,
                            mergedTree.getRoot().getControl(),
                            cqControl
                    );
                } else if (cqControl.getProposition() != null
                        && mergedTree.getRoot()
                                .getControl().getProposition() == null) {
                    cqArgNode = createCQArgPanePremise(
                            targetParent,
                            mergedTree.getRoot().getControl(),
                            cqControl
                    );
                }
                attachNewSubTree(
                        cqArgNode,
                        target,
                        targetParent,
                        mergedTree,
                        futureChildID
                );
                canvasControl.removeArgumentTree(futureChildID);
                collisionAdjustment();
                canvasControl.constructionAreaSizeCheck();
            }
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Method for updating the nexus matrix of ArgumentViewTree when merging
     *
     * @param chainNode ArgumentNode the chain pane connecting the two arguments
     * @param mergedTree ArgumentViewTree argument tree being merged into this
     * one
     */
    private void updateNexusMatrix(
            ArgumentNode chainNode, ArgumentViewTree mergedTree) {
        ArgumentNode chainNodeControllingNexus
                = chainNode.getParent().getParent();
        ListIterator<List<ArgumentNode>> matrixIt = nexusMatrix.listIterator(0);
        List<ArgumentNode> targetLayer = null;
        while (targetLayer == null && matrixIt.hasNext()) {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for (ArgumentNode nexus : inspectedLayer) {
                if (nexus.equals(chainNodeControllingNexus)) {
                    targetLayer = inspectedLayer;
                }
            }
        }
        Iterator<List<ArgumentNode>> mergedTreeIt
                = mergedTree.getNexusMatrix().iterator();

        while (mergedTreeIt.hasNext()) {
            if (!matrixIt.hasNext()) {
                List<ArgumentNode> newLayer = new ArrayList<>();
                for (ArgumentNode nexus : mergedTreeIt.next()) {
                    newLayer.add(nexus);
                }
                matrixIt.add(newLayer);
            } else {
                targetLayer = matrixIt.next();
                for (ArgumentNode nexus : mergedTreeIt.next()) {
                    targetLayer.add(nexus);
                }
            }
        }
    }

    /**
     * Method for updating the pane matrix of ArgumentViewTree when merging
     *
     * @param replacedNode ArgumentNode being removed from the matrix
     * @param chainNode ArgumentNode the chain pane connecting the two arguments
     * @param mergedTree ArgumentViewTree argument tree being merged into this
     * one
     */
    private void updatePaneMatrix(
            ArgumentNode replacedNode,
            ArgumentNode chainNode,
            ArgumentViewTree mergedTree) {
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator(0);
        List<ArgumentNode> targetLayer = null;
        while (targetLayer == null && matrixIt.hasNext()) {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for (ArgumentNode pane : inspectedLayer) {
                if (pane.equals(replacedNode)) {
                    targetLayer = inspectedLayer;
                }
            }
        }
        targetLayer.remove(replacedNode);
        mergedTree.replaceInPaneMatrix(mergedTree.getRoot(), chainNode);
        Iterator<List<ArgumentNode>> mergedTreeIt
                = mergedTree.getPaneMatrix().iterator();
        while (mergedTreeIt.hasNext()) {
            for (ArgumentNode pane : mergedTreeIt.next()) {
                targetLayer.add(pane);
            }
            if (mergedTreeIt.hasNext()) {
                if (!matrixIt.hasNext()) {
                    List<ArgumentNode> newLayer = new ArrayList<>();
                    matrixIt.add(newLayer);
                    targetLayer = matrixIt.previous();
                }
                targetLayer = matrixIt.next();
            }
        }
    }

    /**
     * Method for replacing an ArgumentNode in pane matrix with another
     *
     * @param replacee ArgumentNode to be replaced
     * @param replacement ArgumentNode replacing replacee
     */
    private void replaceInPaneMatrix(
            ArgumentNode replacee,
            ArgumentNode replacement
    ) {
        List<ArgumentNode> targetLayer = null;
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator(0);
        while (targetLayer == null && matrixIt.hasNext()) {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for (ArgumentNode pane : inspectedLayer) {
                if (pane.equals(replacee)) {
                    targetLayer = inspectedLayer;
                }
            }
        }

        targetLayer.remove(replacee);
        targetLayer.add(replacement);
    }

    // Methods for detaching subarguments and CQ's/Counter args
    //--------------------------------------------------------------------------
    /**
     * Method for detaching a sub argument
     *
     * @param chainControl ChainPaneController controller of the chain pane
     * acting as the conclusion of the sub argument being removed
     * @param coords Point2D coordinates where the new argument tree will be
     * drawn
     */
    public void detachArgumentChain(ChainPaneController chainControl,
            Point2D coords) {
        try {
            /*
            get reference to the chain node that is going to be split up and
            its parent
             */
            ArgumentNode target
                    = searchForNode(root, chainControl.getMainPane());
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane(target);

            List<ArgumentNode> targetLayer
                    = findMatrixLayer(target, paneMatrix);
            /*
            get the coordinates for where the new conclusion pane will be
            drawn
             */
            Point2D targetCoords = new Point2D(
                    target.getView().getLayoutX(),
                    target.getView().getLayoutY()
            );

            /*
            create the new premise node and splice it in place of the chain
            node and draw it
             */
            ArgumentNode premiseBox = createPremiseView(
                    chainControl.getPremiseArgument(),
                    targetParent.getView(),
                    chainControl.getPosition()
            );
            targetParent.removeChild(target);
            targetParent.addAsChild(premiseBox);
            premiseBox.setParent(targetParent);
            canvas.getChildren().add(premiseBox.getView());

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(
                            chainControl.getPremiseArgument(),
                            (PremiseNode) premiseBox
                    );
            premiseBox.addAsChild(certaintyBox);
            certaintyBox.setParent(premiseBox);
            canvas.getChildren().add(certaintyBox.getView());

            shrinkParentNexus(premiseBox);
            targetLayer.add(premiseBox);

            /*
            create a new argument tree to contain the conclusion side of the
            split
             */
            ArgumentViewTree newArgTree
                    = new ArgumentViewTree(canvas, canvasControl);

            /*
            make a new conclusion node and attached the branch containing the
            conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion
                    = createConclusionView(
                            chainControl.getConclusionArgumentModel(),
                            targetCoords
                    );
            newConclusion.getControl().setCertaintyController(
                    chainControl.getCertaintyController()
            );
            if (chainControl.getProposition() != null) {
                newConclusion.getControl().addProposition(
                        chainControl.getProposition()
                );
            }
            newConclusion.setArgTree(newArgTree);
            newArgTree.setRoot(newConclusion);
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while (targetChildren.hasNext()) {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild(child);
                child.setParent(newConclusion);
                newArgTree.changeArgTree(child);
                targetChildren.remove();
            }
            canvas.getChildren().add(newConclusion.getView());

            /*
            shift the newly made argument tree so that it's offset from the
            premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode(newConclusion, transX, transY);
            removeNodeFromMatrix(paneMatrix, target);
            targetLayer.add(newConclusion);
            /*
            clean up chain pane and register the new tree with the
            cinstruction area
             */
            canvas.getChildren().remove(target.getView());
            canvasControl.registerNewArgTree(newArgTree);

            updateAllCollisionMatricesOnDetach(newArgTree);
            collisionAdjustment();
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Method for detaching a multiple arguments sharing the same conclusion
     * acting as a sub argument
     *
     * @param chainControl MultiArgChainPaneController controller of the pane
     * acting as the conclusion of the sub argument being removed
     * @param coords Point2D coordinates where the new argument tree will be
     * drawn
     */
    public void detachArgumentChain(MultiArgChainPaneController chainControl,
            Point2D coords) {
        try {
            /*
            get reference to the chain node that is going to be split up and
            its parent
             */
            ArgumentNode target
                    = searchForNode(root, chainControl.getMainPane());
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane(target);
            List<ArgumentNode> targetLayer
                    = findMatrixLayer(target, paneMatrix);
            /*
            create the new premise node and splice it in place of the chain
            node and draw it
             */
            ArgumentNode premiseBox = createPremiseView(
                    chainControl.getPremiseArgument(),
                    targetParent.getView(),
                    chainControl.getPosition()
            );
            targetParent.removeChild(target);
            targetParent.addAsChild(premiseBox);
            premiseBox.setParent(targetParent);
            canvas.getChildren().add(premiseBox.getView());

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(
                            chainControl.getPremiseArgument(),
                            (PremiseNode) premiseBox
                    );
            premiseBox.addAsChild(certaintyBox);
            certaintyBox.setParent(premiseBox);
            canvas.getChildren().add(certaintyBox.getView());

            shrinkParentNexus(premiseBox);
            targetLayer.add(premiseBox);

            /*
            create a new argument tree to contain the conclusion side of the
            split
             */
            ArgumentViewTree newArgTree
                    = new ArgumentViewTree(canvas, canvasControl);

            /*
            make a new conclusion node and attached the branch containing the
            conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion
                    = createNewMultiArgConclusion(
                            target,
                            chainControl
                    );
            newConclusion.setArgTree(newArgTree);
            newArgTree.setRoot(newConclusion);
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while (targetChildren.hasNext()) {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild(child);
                child.setParent(newConclusion);
                newArgTree.changeArgTree(child);
                targetChildren.remove();
            }
            canvas.getChildren().add(newConclusion.getView());

            /*
            shift the newly made argument tree so that it's offset from the
            premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode(newConclusion, transX, transY);

            removeNodeFromMatrix(paneMatrix, target);
            targetLayer.add(newConclusion);
            /*
            clean up chain pane and register the new tree with the
            cinstruction area
             */
            canvas.getChildren().remove(target.getView());
            canvasControl.registerNewArgTree(newArgTree);

            updateAllCollisionMatricesOnDetach(newArgTree);
            collisionAdjustment();
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Method for detaching counter arguments from argument structures
     *
     * @param counterChainControl CounterArgumentPaneController controller of
     * the pane acting as the conclusion of the counter argument being removed
     * @param coords Point2D coordinates where the new ArgumentViewTree will be
     * drawn
     */
    public void detachArgumentChain(
            CounterArgumentPaneController counterChainControl,
            Point2D coords) {
        try {
            /*
            get reference to the chain node that is going to be split up and
            its parent
             */
            ArgumentNode target
                    = searchForNode(root, counterChainControl.getMainPane());
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane(target);

            List<ArgumentNode> targetLayer
                    = findMatrixLayer(target, paneMatrix);
            /*
            get the coordinates for where the new conclusion pane will be
            drawn
             */
            Point2D targetCoords = new Point2D(
                    target.getView().getLayoutX(),
                    target.getView().getLayoutY()
            );

            /*
            create the new counter premise node and splice it in place of the 
            chain node and draw it. Also replace the arguments in the parent's
            counter arg list
             */
            CounterArgumentModel counterArg = new CounterArgumentModel();
            counterChainControl.addCounterArgumentToParentModels(counterArg);
            counterChainControl.removeCounterArgumentFromParentModels(
                    counterChainControl.getArgument()
            );

            CounterPropositionNode counterPropBox
                    = (CounterPropositionNode) createCounterPropositionView(
                            counterChainControl.getParentModelList(),
                            counterArg,
                            targetParent
                    );
            targetParent.removeChild(target);
            targetParent.addAsChild(counterPropBox);
            counterPropBox.setParent(targetParent);
            canvas.getChildren().add(counterPropBox.getView());
            shrinkParentNexus(counterPropBox);
            targetLayer.add(counterPropBox);

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(
                            counterArg.getConclusion(),
                            (CounterPropositionNode) counterPropBox
                    );
            counterPropBox.addAsChild(certaintyBox);
            certaintyBox.setParent(counterPropBox);
            canvas.getChildren().add(certaintyBox.getView());

            /*
            replace dechained argument from parent premise and add the new 
            argument
             */
 /*
            create a new argument tree to contain the conclusion side of the
            split
             */ ArgumentViewTree newArgTree
                    = new ArgumentViewTree(canvas, canvasControl);

            /*
            make a new conclusion node and attached the branch containing the
            conclusion side of the chain node to it and draw it
             */
            //convert counter argument to regular argument
            ArgumentModel newArg
                    = new ArgumentModel(
                            counterChainControl.getArgument()
                    );
            ConclusionNode newConclusion
                    = createConclusionView(
                            newArg,
                            targetCoords
                    );
            newConclusion.getControl().setCertaintyController(
                    counterChainControl.getCertaintyController()
            );
            if (counterChainControl.getProposition() != null) {
                newConclusion.getControl().addProposition(
                        counterChainControl.getProposition()
                );
            }
            newConclusion.setArgTree(newArgTree);
            newArgTree.setRoot(newConclusion);
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while (targetChildren.hasNext()) {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild(child);
                child.setParent(newConclusion);
                newArgTree.changeArgTree(child);
                targetChildren.remove();
            }
            canvas.getChildren().add(newConclusion.getView());

            /*
            shift the newly made argument tree so that it's offset from the
            premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode(newConclusion, transX, transY);

            removeNodeFromMatrix(paneMatrix, target);
            targetLayer.add(newConclusion);
            /*
            clean up chain pane and register the new tree with the
            cinstruction area
             */
            canvas.getChildren().remove(target.getView());
            canvasControl.registerNewArgTree(newArgTree);

            shrinkCounterArgumentConnection(target);
            updateAllCollisionMatricesOnDetach(newArgTree);
            collisionAdjustment();
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * Method for detaching critical question arguments from argument structures
     *
     * @param cqArgControl CQArgumentPaneController controller of the pane
     * acting as the conclusion of the counter argument being removed
     * @param coords Point2D coordinates where the new ArgumentViewTree will be
     * drawn
     */
    public void detachArgumentChain(
            CQArgumentPaneController cqArgControl,
            Point2D coords) {
        try {
            /*
            get reference to the chain node that is going to be split up and
            its parent
             */
            ArgumentNode target
                    = searchForNode(root, cqArgControl.getMainPane());
            ArgumentNode targetParent = target.getParent();
            deleteCommentPane(target);

            List<ArgumentNode> targetLayer
                    = findMatrixLayer(target, paneMatrix);
            /*
            get the coordinates for where the new conclusion pane will be
            drawn
             */
            Point2D targetCoords = new Point2D(
                    target.getView().getLayoutX(),
                    target.getView().getLayoutY()
            );

            /*
            create the new CQ premise node and splice it in place of the 
            chain node and draw it. Also replace the arguments in the parent's
            CQ arg list
             */
            ArgumentModel cqArg = new ArgumentModel();
            cqArgControl.addArgumentToParentCQArgList(cqArg);
            cqArgControl.removeArgumentFromParentCQArgList(
                    cqArgControl.getArgument()
            );

            CQNode cqBox
                    = (CQNode) createCQView(
                            cqArg,
                            cqArgControl.getParentArgument(),
                            targetParent
                    );
            targetParent.removeChild(target);
            targetParent.addAsChild(cqBox);
            cqBox.setParent(targetParent);
            canvas.getChildren().add(cqBox.getView());
            shrinkParentNexus(cqBox);
            targetLayer.add(cqBox);

            ArgumentNode certaintyBox
                    = createArgumentCertaintyBox(
                            cqArg.getConclusion(),
                            cqBox
                    );
            cqBox.addAsChild(certaintyBox);
            certaintyBox.setParent(cqBox);
            canvas.getChildren().add(certaintyBox.getView());

            /*
            replace dechained argument from parent premise and add the new 
            argument
             */
 /*
            create a new argument tree to contain the conclusion side of the
            split
             */ ArgumentViewTree newArgTree
                    = new ArgumentViewTree(canvas, canvasControl);

            /*
            make a new conclusion node and attached the branch containing the
            conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion
                    = createConclusionView(
                            cqArgControl.getArgument(),
                            targetCoords
                    );
            newConclusion.getControl().setCertaintyController(
                    cqArgControl.getCertaintyController()
            );
            if (cqArgControl.getProposition() != null) {
                newConclusion.getControl().addProposition(
                        cqArgControl.getProposition()
                );
            }
            newConclusion.setArgTree(newArgTree);
            newArgTree.setRoot(newConclusion);
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while (targetChildren.hasNext()) {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild(child);
                child.setParent(newConclusion);
                newArgTree.changeArgTree(child);
                targetChildren.remove();
            }
            canvas.getChildren().add(newConclusion.getView());

            /*
            shift the newly made argument tree so that it's offset from the
            premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode(newConclusion, transX, transY);

            removeNodeFromMatrix(paneMatrix, target);
            targetLayer.add(newConclusion);
            /*
            clean up chain pane and register the new tree with the
            cinstruction area
             */
            canvas.getChildren().remove(target.getView());
            canvasControl.registerNewArgTree(newArgTree);

            updateAllCollisionMatricesOnDetach(newArgTree);
            collisionAdjustment();
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }

    /**
     * recursively traverses up the tree and shrinks all nexus nodes it finds on
     * the way to root to their default value (determined by the number of
     * premises controlled by the nexus).
     *
     * @param node
     */
    private void shrinkParentNexus(ArgumentNode node) {
        // if a premise node is visited
        if (node instanceof PremiseNexusNode) {
            /*
            cast node to a nexus node and resize to original default size
             */
            PremiseNexusNode nexusNode = (PremiseNexusNode) node;
            double amountShrunk = resizeNexusToDefault(nexusNode);
            /*
            shift node so that it is centered relative to its parent
             */
            nexusNode.getView().setLayoutX(
                    node.getView().getLayoutX() + (amountShrunk / 2)
            );
            /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
             */
            shiftNexusChildrenOnDetach(nexusNode);
        }
        if (!node.equals(root)) {
            shrinkParentNexus(node.getParent());
        }
    }

    /**
     * translates children of nexus nodes to their new positions on the nexus
     * after a nexus is shrunk on a detachment
     *
     * @param nexusNode PremiseNexusNode
     */
    private void shiftNexusChildrenOnDetach(PremiseNexusNode nexusNode) {
        int numChildren = nexusNode.getChildren().size();
        for (int i = 0; i < numChildren; i++) {
            translateNode(nexusNode.getChildren().get(i),
                    (nexusNode.getView().getBoundsInParent()
                            .getMinX()
                    - nexusNode.getChildren().get(i).getView()
                            .getBoundsInParent()
                            .getMinX())
                    + (i * (PREMISE_WIDTH + PADDING)),
                    (nexusNode.getView().getBoundsInParent()
                            .getMaxY()
                    - nexusNode.getChildren().get(i).getView()
                            .getBoundsInParent()
                            .getMinY())
            );
        }
    }

    /**
     * resizes a nexus node to it's default size, determined by the number of
     * premises it controls. Returns the amount the nexus was shrunk
     *
     * @param nexus PremiseNexusNode
     * @return double
     */
    private double resizeNexusToDefault(PremiseNexusNode nexus) {
        double currentWidth = nexus.getView().getBoundsInParent().getWidth();
        nexus.resizeToDefaultWidth();
        double defaultWidth = nexus.getView().getBoundsInParent().getWidth();
        return (currentWidth - defaultWidth);
    }

    /**
     * method iterates through the layers of the specified matrices on the
     * detachment of argument subtree and transfers the nexus node references to
     * the new detached tree
     *
     * @param newTree newly created tree
     * @param parentMatrix tree that the new tree was detached from
     * @param newMatrix matrix of the new tree
     */
    private void updateMatrixOnDetach(
            ArgumentViewTree newTree,
            List<List<ArgumentNode>> parentMatrix,
            List<List<ArgumentNode>> newMatrix
    ) {
        ListIterator<List<ArgumentNode>> newMatrixIt
                = newMatrix.listIterator();
        ListIterator<List<ArgumentNode>> parentMatrixIt
                = parentMatrix.listIterator();

        while (parentMatrixIt.hasNext()) {
            //create a new layer to possibly add to the new tree's nexus matrix
            List<ArgumentNode> newTreeNexusLayer = new ArrayList<>();
            List<ArgumentNode> currentSearchLayer = parentMatrixIt.next();
            ListIterator<ArgumentNode> currentSearchLayerIt
                    = currentSearchLayer.listIterator();
            // iterate through a layer of the original matrix
            while (currentSearchLayerIt.hasNext()) {
                ArgumentNode currentNode = currentSearchLayerIt.next();
                if (newTree.containsNode(currentNode)) {
                    /*
                    if the new tree contains a nexus found in the old tree's
                    matrix, add it to the layer created earlier and remove the
                    reference to that node from the old matrix
                     */
                    newTreeNexusLayer.add(currentNode);
                    currentSearchLayerIt.remove();
                }
            }
            /*
            if anything was added to the layer made earlier, add it as a layer
            to the new tree's matrix
             */
            if (!newTreeNexusLayer.isEmpty()) {
                newMatrixIt.add(newTreeNexusLayer);
            }
            /*
            if the layer we were looking at in the old matrix is now empty,
            remove that layer
             */
            if (currentSearchLayer.isEmpty()) {
                parentMatrixIt.remove();
            }
        }
    }

    //Adding critical questions to an argument structure
    //--------------------------------------------------------------------------
    public void addCriticalQuestion(
            ArgumentModel arg,
            ArgumentNode schemeLabel,
            int cqNum
    ) throws IOException {
        if (!arg.hasCQ()) {
            createNewCQStructure(arg, schemeLabel, cqNum);
            arg.setCQ(true);
        } else {
            addAdditionalCriticalQuestion(arg, schemeLabel, cqNum);
        }
    }

    public void addAdditionalCriticalQuestion(
            ArgumentModel parentArg,
            ArgumentNode schemeLabel,
            int cqNum) throws IOException {
        // get main connector
        CQConnectionNode mainConnector = null;
        for (ArgumentNode child : schemeLabel.getParent().getChildren()) {
            if (child instanceof CQConnectionNode) {
                mainConnector = (CQConnectionNode) child;
            }
        }

        //get nexus
        PremiseNexusNode nexus
                = (PremiseNexusNode) findNextNexus(mainConnector);

        //create a connector for the new counter arg
        ArgumentNode specificCQConnector
                = createPremiseConnection(nexus.getView(), 0);
        nexus.addAsChild(specificCQConnector);
        specificCQConnector.setParent(nexus);
        canvas.getChildren().add(specificCQConnector.getView());

        // create new label for CQ
        ArgumentNode cqLabel = new CQLabel(
                parentArg.getPatchCriticalQuestion(cqNum),
                getRelativeLayout(specificCQConnector.getView()),
                this,
                canvas,
                specificCQConnector
        );
        cqLabel.setParent(specificCQConnector);
        specificCQConnector.addAsChild(cqLabel);
        canvas.getChildren().add(cqLabel.getView());

        // create new CQ pane
        ArgumentModel newArg = new ArgumentModel();
        ArgumentNode cqPremise = createCQView(
                newArg,
                parentArg,
                specificCQConnector
        );
        specificCQConnector.addAsChild(cqPremise);
        cqPremise.setParent(specificCQConnector);
        canvas.getChildren().add(cqPremise.getView());

        ArgumentNode certaintyBox
                = createArgumentCertaintyBox(
                        newArg.getConclusion(),
                        (CQNode) cqPremise
                );
        cqPremise.addAsChild(certaintyBox);
        certaintyBox.setParent(cqPremise);
        canvas.getChildren().add(certaintyBox.getView());

        // adjust nexus size
        double amountShrunk = resizeNexusToDefault(nexus);
        /*
            shift node so that it is centered relative to its parent
         */
        nexus.getView().setLayoutX(
                nexus.getView().getLayoutX()
                + (amountShrunk / 2)
        );
        /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
         */
        shiftNexusChildrenOnDetach(nexus);
        /*
        add new CQ pane to matrix
         */
        // add CQ pane
        List<ArgumentNode> targetLayer
                = paneMatrix.get(paneMatrix.indexOf(
                        findMatrixLayer(
                                schemeLabel.getParent(), paneMatrix
                        )
                )
                        + 1
                );
        targetLayer.add(cqPremise);

        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void createNewCQStructure(
            ArgumentModel parentArg,
            ArgumentNode schemeLabel,
            int cqNum
    ) throws IOException {
        ArgumentNode mainCQConnector = createCQConnection(parentArg, schemeLabel.getParent());
        schemeLabel.getParent().addAsChild(mainCQConnector);
        mainCQConnector.setParent(schemeLabel.getParent());
        canvas.getChildren().add(mainCQConnector.getView());

        ArgumentNode cqIcon = createCQIcon(mainCQConnector);
        cqIcon.setParent(mainCQConnector);
        mainCQConnector.addAsChild(cqIcon);
        canvas.getChildren().add(cqIcon.getView());

        ArgumentNode nexus
                = createNexus(
                        1,
                        cqIcon.getView()
                );
        cqIcon.addAsChild(nexus);
        nexus.setParent(cqIcon);
        canvas.getChildren().add(nexus.getView());
        /*
        add new nexus to matrix
         */
        List<ArgumentNode> targetNexusLayer
                = nexusMatrix.get(nexusMatrix.indexOf(
                        findMatrixLayer(
                                findNextNexus(
                                        schemeLabel.getParent()
                                ), nexusMatrix
                        )
                ));
        targetNexusLayer.add(nexus);

        ArgumentNode cqConnect
                = createPremiseConnection(nexus.getView(), 0);
        nexus.addAsChild(cqConnect);
        cqConnect.setParent(nexus);
        canvas.getChildren().add(cqConnect.getView());

        ArgumentNode cqLabel = new CQLabel(
                parentArg.getPatchCriticalQuestion(cqNum),
                getRelativeLayout(cqConnect.getView()),
                this,
                canvas,
                cqConnect
        );
        cqLabel.setParent(cqConnect);
        cqConnect.addAsChild(cqLabel);
        canvas.getChildren().add(cqLabel.getView());

        ArgumentModel newArg = new ArgumentModel();
        ArgumentNode cqPremise = createCQView(
                newArg,
                parentArg,
                cqConnect
        );
        cqConnect.addAsChild(cqPremise);
        cqPremise.setParent(cqConnect);
        canvas.getChildren().add(cqPremise.getView());

        ArgumentNode certaintyBox
                = createArgumentCertaintyBox(
                        newArg.getConclusion(),
                        (CQNode) cqPremise
                );
        cqPremise.addAsChild(certaintyBox);
        certaintyBox.setParent(cqPremise);
        canvas.getChildren().add(certaintyBox.getView());

        /*
        add new CQ pane to matrix
         */
        // add CQ pane
        List<ArgumentNode> targetPaneLayer
                = paneMatrix.get(paneMatrix.indexOf(
                        findMatrixLayer(schemeLabel.getParent(), paneMatrix
                        )
                )
                        + 1
                );
        targetPaneLayer.add(cqPremise);

        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    public void deleteCriticalQuestion(CQPaneController controller) {
        /*
            get node reference to the CQ that is going to deleted
         */
        ArgumentNode target
                = searchForNode(root, controller.getMainPane());
        deleteCommentPane(target);
        ArgumentNode targetConnector = target.getParent();
        ArgumentNode targetNexus = targetConnector.getParent();

        /*
            remove pane and connector from structure
         */
        ListIterator<ArgumentNode> childIT
                = targetNexus.getChildren().listIterator();
        while (childIT.hasNext()) {
            ArgumentNode child = childIT.next();
            if (child.equals(targetConnector)) {
                eraseTree(child);
                childIT.remove();
            }
        }
        eraseTree(targetConnector);
        removeSubTreeFromMatrices(target);

        /*
            resize nexus to accomidate new number of children
         */
        //cast node to a nexus node and resize to original default size
        PremiseNexusNode nexusNode = (PremiseNexusNode) targetNexus;
        double amountShrunk = resizeNexusToDefault(nexusNode);
        //shift node so that it is centered relative to its parent
        nexusNode.getView().setLayoutX(
                targetNexus.getView().getLayoutX() + (amountShrunk / 2)
        );
        //reposition subtrees of nexus so that they are in the correct
        //relative positions
        shiftNexusChildrenOnDetach(nexusNode);
        /*
            check if we need to remove the counter argument structure
            i.e. if there are no arguments left in the structure
         */
        if (targetNexus.getChildren().isEmpty()) {
            // remove nexus
            canvas.getChildren().remove(targetNexus.getView());
            //remove icon
            ArgumentNode cqIcon = targetNexus.getParent();
            canvas.getChildren().remove(cqIcon.getView());
            //remove horizontal connector
            ArgumentNode horizontalIcon = cqIcon.getParent();
            canvas.getChildren().remove(horizontalIcon.getView());
            //remove logical reference to the structure
            horizontalIcon.getParent().removeChild(horizontalIcon);
            // resent counter argument flag in parent argument
            controller.getParentArgument().setCQ(false);
        }
        collisionAdjustment();
    }

    // Adding counter arguments to an argument structure
    //--------------------------------------------------------------------------
    public void addCounterArgument(
            List<PremiseModel> targetModelList,
            ArgumentNode parent
    ) throws IOException {
        if (!containsCounterArguments(targetModelList)) {
            addCounterArgumentPane(targetModelList, parent);
        } else {
            addAdditionalCounterArg(targetModelList, parent);
        }
    }

    public void addCounterArgument(
            PremiseModel targetModel,
            ArgumentNode parent
    ) throws IOException {
        List<PremiseModel> targetModelList = new ArrayList<>();
        targetModelList.add(targetModel);
        if (!containsCounterArguments(targetModelList)) {
            addCounterArgumentPane(targetModelList, parent);
        } else {
            addAdditionalCounterArg(targetModelList, parent);
        }
    }

    private boolean containsCounterArguments(List<PremiseModel> modelList) {
        for (PremiseModel model : modelList) {
            if (model.hasCounterArgument()) {
                return true;
            }
        }
        return false;
    }

    private void addAdditionalCounterArg(
            List<PremiseModel> parentModelList,
            ArgumentNode parent) throws IOException {
        //find the counter arg connection
        CounterArgumentConnectionNode rootConnector = null;
        for (ArgumentNode child : parent.getChildren()) {
            if (child instanceof CounterArgumentConnectionNode) {
                rootConnector = (CounterArgumentConnectionNode) child;
            }
        }
        // get the matrix layer below the parent node
        List<ArgumentNode> targetMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer(parent, paneMatrix)
                        )
                        + 1
                );
        //get nexus
        PremiseNexusNode nexus
                = (PremiseNexusNode) findNextNexus(rootConnector);

        //create a connector for the new counter arg
        ArgumentNode specificCounterConnector
                = createPremiseConnection(nexus.getView(), 0);
        nexus.addAsChild(specificCounterConnector);
        specificCounterConnector.setParent(nexus);
        canvas.getChildren().add(specificCounterConnector.getView());

        /*
        create new argument model for counter argument and a new pane for counter arg
         */
        CounterArgumentModel counterArg = new CounterArgumentModel();
        ArgumentNode counterPane
                = createCounterPropositionView(
                        parentModelList,
                        counterArg,
                        specificCounterConnector
                );
        specificCounterConnector.addAsChild(counterPane);
        counterPane.setParent(specificCounterConnector);
        canvas.getChildren().add(counterPane.getView());
        //add counter argument to parent arg's counter argument list
        for (PremiseModel model : parentModelList) {
            model.addCounterArgument(counterArg);
        }
        // add counter counter pane to matrix
        targetMatrixLayer.add(counterPane);

        ArgumentNode certaintyBox
                = createArgumentCertaintyBox(
                        counterArg.getConclusion(),
                        (CounterPropositionNode) counterPane
                );
        counterPane.addAsChild(certaintyBox);
        certaintyBox.setParent(counterPane);
        canvas.getChildren().add(certaintyBox.getView());

        // adjust nexus size
        double amountShrunk = resizeNexusToDefault(nexus);
        /*
            shift node so that it is centered relative to its parent
         */
        nexus.getView().setLayoutX(
                nexus.getView().getLayoutX()
                + (amountShrunk / 2)
        );
        /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
         */
        shiftNexusChildrenOnDetach(nexus);

        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void addCounterArgumentPane(
            List<PremiseModel> parentModelList,
            ArgumentNode parent
    ) throws IOException {
        ArgumentNode counterConnector
                = createCounterArgumentConnection(parent.getView());
        parent.addAsChild(counterConnector);
        counterConnector.setParent(parent);
        canvas.getChildren().add(counterConnector.getView());

        ArgumentNode counterIcon = createCounterIcon(counterConnector);
        counterIcon.setParent(counterConnector);
        counterConnector.addAsChild(counterIcon);
        canvas.getChildren().add(counterIcon.getView());

        ArgumentNode counterSecondaryConnector
                = createPremiseConnection(counterIcon.getView(), 0);
        counterIcon.addAsChild(counterSecondaryConnector);
        counterSecondaryConnector.setParent(counterIcon);
        canvas.getChildren().add(counterSecondaryConnector.getView());
        translateNode(counterSecondaryConnector, 60 - 3, 0);

        ArgumentNode nexus
                = createNexus(
                        1,
                        counterSecondaryConnector.getView()
                );
        counterSecondaryConnector.addAsChild(nexus);
        nexus.setParent(counterSecondaryConnector);
        canvas.getChildren().add(nexus.getView());
        /*
        add nexus to matrix
         */
        List<ArgumentNode> targetNexusLayer
                = findMatrixLayer(findNextNexus(parent), nexusMatrix);
        targetNexusLayer.add(nexus);

        ArgumentNode specificCounterConnector
                = createPremiseConnection(nexus.getView(), 0);
        nexus.addAsChild(specificCounterConnector);
        specificCounterConnector.setParent(nexus);
        canvas.getChildren().add(specificCounterConnector.getView());

        // create new argument model for counter argument
        CounterArgumentModel counterArg = new CounterArgumentModel();
        ArgumentNode counterPane
                = createCounterPropositionView(
                        parentModelList,
                        counterArg,
                        specificCounterConnector
                );
        specificCounterConnector.addAsChild(counterPane);
        counterPane.setParent(specificCounterConnector);
        canvas.getChildren().add(counterPane.getView());
        //add counter argument to parent arg's counter argument list
        for (PremiseModel model : parentModelList) {
            model.addCounterArgument(counterArg);
        }

        ArgumentNode certaintyBox
                = createArgumentCertaintyBox(
                        counterArg.getConclusion(),
                        (CounterPropositionNode) counterPane
                );
        counterPane.addAsChild(certaintyBox);
        certaintyBox.setParent(counterPane);
        canvas.getChildren().add(certaintyBox.getView());

        updateNexusMatrix(parent, counterIcon, counterPane);
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    public void deleteCounterArgument(
            CounterArgumentPaneController controller,
            List<PremiseModel> parentModelList,
            CounterArgumentModel counterArgument) {
        /*
            get reference to the counter argument that is going to deleted
         */
        ArgumentNode target
                = searchForNode(root, controller.getMainPane());
        deleteCommentPane(target);
        deleteCounterArgument(
                target,
                counterArgument,
                parentModelList
        );

    }

    public void deleteCounterArgument(
            CounterPropositionPaneController controller,
            List<PremiseModel> parentModelList,
            CounterArgumentModel counterArgument) {
        /*
            get reference to the counter argument that is going to deleted
         */
        ArgumentNode target
                = searchForNode(root, controller.getMainPane());
        deleteCommentPane(target);
        deleteCounterArgument(
                target,
                counterArgument,
                parentModelList
        );
    }

    private void deleteCounterArgument(
            ArgumentNode target,
            CounterArgumentModel counterArgument,
            List<PremiseModel> parentCounterArgumentList) {

        // Get connector nodes
        ArgumentNode targetConnector = target.getParent();
        ArgumentNode targetNexus = targetConnector.getParent();
        deleteCommentPane(target);
        /*
            remove pane and connector from structure
         */
        ListIterator<ArgumentNode> childIT
                = targetNexus.getChildren().listIterator();
        while (childIT.hasNext()) {
            ArgumentNode child = childIT.next();
            if (child.equals(targetConnector)) {
                childIT.remove();
            }
        }
        eraseTree(targetConnector);
        removeSubTreeFromMatrices(target);

        // remove counter argument from parent counter arg list
        for (PremiseModel parentModel : parentCounterArgumentList) {
            parentModel.getCounterArgumentList().remove(counterArgument);
        }

        /*
            resize nexus to accomidate new number of children
         */
        //cast node to a nexus node and resize to original default size
        PremiseNexusNode nexusNode = (PremiseNexusNode) targetNexus;
        double amountShrunk = resizeNexusToDefault(nexusNode);
        //shift node so that it is centered relative to its parent
        nexusNode.getView().setLayoutX(
                targetNexus.getView().getLayoutX() + (amountShrunk / 2)
        );
        //reposition subtrees of nexus so that they are in the correct
        //relative positions
        shiftNexusChildrenOnDetach(nexusNode);

        /*
            check if we need to remove the counter argument structure
            i.e. if there are no arguments left in the structure
         */
        if (targetNexus.getChildren().isEmpty()) {
            // undraw nexus
            canvas.getChildren().remove(targetNexus.getView());
            removeNodeFromMatrix(nexusMatrix, targetNexus);
            //remove vertiacl connection
            ArgumentNode verticalConnector = targetNexus.getParent();
            canvas.getChildren().remove(verticalConnector.getView());
            //remove icon
            ArgumentNode counterIcon = verticalConnector.getParent();
            canvas.getChildren().remove(counterIcon.getView());
            removeNodeFromMatrix(paneMatrix, counterIcon);
            //remove horizontal connector
            ArgumentNode horizontalIcon = counterIcon.getParent();
            canvas.getChildren().remove(horizontalIcon.getView());
            // shrink parent nexuses
            shrinkParentNexus(horizontalIcon.getParent());
            //remove logical reference to the structure
            horizontalIcon.getParent().removeChild(horizontalIcon);
        }
        collisionAdjustment();
    }

    /**
     * Shrink the counter argument connection that counterPane is attached to
     * and shift over all related elements in the sub-tree to the new position
     *
     * @param counterPane ArgumentNode a counter argument pane
     */
    private void shrinkCounterArgumentConnection(ArgumentNode counterPane) {
        /*
            cast node to a nexus node and resize to original default size
         */
        CounterArgumentConnectionNode counterConnection
                = (CounterArgumentConnectionNode) findCounterConnection(
                        counterPane
                );
        double amountShrunk
                = resizeCounterConnectionToDefault(counterConnection);

        /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
         */
        for (ArgumentNode child : counterConnection.getChildren()) {
            translateNode(child, -amountShrunk, 0);
        }
    }

    /**
     * Resizes a counter connection to its default size
     *
     * @param counterConnection ArgumentNode
     * @return double amount shrunk
     */
    private double resizeCounterConnectionToDefault(
            CounterArgumentConnectionNode counterConnection) {
        double currentWidth
                = counterConnection.getView().getBoundsInParent().getWidth();
        counterConnection.resizeToDefaultWidth();
        double defaultWidth
                = counterConnection.getView().getBoundsInParent().getWidth();
        return (currentWidth - defaultWidth);
    }

    /**
     * Recurses up an argument tree to find the first ancestor that is an
     * instance of a CounterArgumentConnectionNode
     *
     * @param node ArgumentNode being inspected
     * @return CounterArgumentConnectionNode
     */
    private CounterArgumentConnectionNode findCounterConnection(
            ArgumentNode node) {
        if (node != null) {
            if (node instanceof CounterArgumentConnectionNode) {
                return (CounterArgumentConnectionNode) node;
            }
            return findCounterConnection(node.getParent());
        }
        return null;
    }

    // Methods for handeling Multiple arguments supporting the same conclusion
    //--------------------------------------------------------------------------
    public void createMultiArgBranch(String mergeTreeID,
            ConclusionPaneController mainTreeControl) throws IOException {
        int numPremises = 2;
        ArgumentViewTree mergedTree = canvasControl.getArgTree(mergeTreeID);
        mergedTree.deleteCommentPanes();
        ConclusionNode mergeTreeRoot = mergedTree.getRoot();
        if (!(mergeTreeRoot.getControl() instanceof MultiArgConclusionPaneController)) {
            ConclusionNode mainConNode
                    = (ConclusionNode) searchForNode(
                            root,
                            mainTreeControl.getMainPane()
                    );

            ArgumentNode targetMatrix = findNextNexus(mainConNode);
            List<ArgumentNode> targetNexusMatrixLayer
                    = findMatrixLayer(targetMatrix, nexusMatrix);
            List<ArgumentNode> targetPaneMatrixLayer
                    = findMatrixLayer(mainConNode, paneMatrix);

            ConclusionNode newConclusion
                    = createNewMultiArgConclusion(
                            mainConNode,
                            mainTreeControl,
                            mergeTreeRoot.getControl()
                    );

            root = newConclusion;

            ArgumentNode connector
                    = createConclusionConnector(root.getView());
            root.addAsChild(connector);
            connector.setParent(root);
            canvas.getChildren().add(connector.getView());

            ArgumentNode label
                    = createMultiArgLabel(root.getView());
            root.addAsChild(label);
            label.setParent(root);
            canvas.getChildren().add(label.getView());

            ArgumentNode nexus = createNexus(numPremises, connector.getView());
            connector.addAsChild(nexus);
            nexus.setParent(connector);
            canvas.getChildren().add(nexus.getView());

            ArgumentNode multiArgPremiseConnect
                    = createMultiArgPremiseConnection(nexus.getView(), 0);
            nexus.addAsChild(multiArgPremiseConnect);
            multiArgPremiseConnect.setParent(nexus);
            canvas.getChildren().add(multiArgPremiseConnect.getView());

            ArgumentNode multiArgSub = createMultiArgSubView(
                    mainConNode.getControl().getConclusionArgumentModel(),
                    multiArgPremiseConnect.getView(),
                    mainConNode.getControl().getCertaintyController(),
                    0
            );

            multiArgPremiseConnect.addAsChild(multiArgSub);
            multiArgSub.setParent(multiArgPremiseConnect);
            canvas.getChildren().add(multiArgSub.getView());

            replaceConnectorWithMultiArgConnector(mainConNode);

            translateNode(mainConNode,
                    multiArgSub.getView().getBoundsInParent().getMinX()
                    - mainConNode.getView().getBoundsInParent().getMinX()
                    - ((PREMISE_WIDTH - 40) / 2),
                    multiArgSub.getView().getBoundsInParent().getMinY()
                    - mainConNode.getView().getBoundsInParent().getMinY()
                    - (PREMISE_HEIGHT - 40)
            );
            ListIterator<ArgumentNode> mainConChildrenIT
                    = mainConNode.getChildren().listIterator();
            while (mainConChildrenIT.hasNext()) {
                ArgumentNode child = mainConChildrenIT.next();
                multiArgSub.addAsChild(child);
                child.setParent(multiArgSub);
                mainConChildrenIT.remove();
            }
            for (ArgumentNode node : multiArgSub.getChildren()) {
                if (node instanceof ArgumentCertaintyNode) {
                    node.getView().setLayoutX(node.getView().getLayoutX() - 85);
                }
                if (node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel) {
                    translateNode(node, 0, 205);
                }
            }
            replaceInPaneMatrix(mainConNode, multiArgSub);

            ArgumentNode multiArgPremiseConnectB
                    = createMultiArgPremiseConnection(nexus.getView(), 1);
            nexus.addAsChild(multiArgPremiseConnectB);
            multiArgPremiseConnectB.setParent(nexus);
            canvas.getChildren().add(multiArgPremiseConnectB.getView());

            ArgumentNode multiArgSubB = createMultiArgSubView(
                    mergeTreeRoot.getControl().getConclusionArgumentModel(),
                    multiArgPremiseConnectB.getView(),
                    mergeTreeRoot.getControl().getCertaintyController(),
                    1
            );

            replaceConnectorWithMultiArgConnector(mergeTreeRoot);

            multiArgPremiseConnectB.addAsChild(multiArgSubB);
            multiArgSubB.setParent(multiArgPremiseConnectB);
            canvas.getChildren().add(multiArgSubB.getView());
            mergedTree.translateTree(
                    multiArgSubB.getView().getBoundsInParent().getMinX()
                    - ((PREMISE_WIDTH - 40) / 2),
                    multiArgSubB.getView().getBoundsInParent().getMinY()
                    - (PREMISE_HEIGHT - 40)
            );
            ListIterator<ArgumentNode> mergeConChildrenIT
                    = mergedTree.getRoot().getChildren().listIterator();
            while (mergeConChildrenIT.hasNext()) {
                ArgumentNode child = mergeConChildrenIT.next();
                multiArgSubB.addAsChild(child);
                child.setParent(multiArgSubB);
                mergeConChildrenIT.remove();
            }
            for (ArgumentNode node : multiArgSubB.getChildren()) {
                if (node instanceof ArgumentCertaintyNode) {
                    node.getView().setLayoutX(node.getView().getLayoutX() - 85);
                }
                if (node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel) {
                    translateNode(node, 0, 205);
                }
            }
            mergedTree.replaceInPaneMatrix(mergedTree.getRoot(), multiArgSubB);

            changeArgTree(root);

            canvas.getChildren().add(newConclusion.getView());
            canvas.getChildren().remove(mainConNode.getView());

            canvasControl.removeArgumentTree(mergeTreeID);
            canvas.getChildren().remove(mergeTreeRoot.getView());

            mergeMatrices(
                    targetPaneMatrixLayer,
                    paneMatrix,
                    mergedTree.paneMatrix
            );
            mergeMatrices(
                    targetNexusMatrixLayer,
                    nexusMatrix,
                    mergedTree.nexusMatrix
            );
            updateNexusMatrixShiftForward(nexus, paneMatrix);
            updateNexusMatrixShiftForward(nexus, nexusMatrix);
            targetPaneMatrixLayer.add(newConclusion);
            targetNexusMatrixLayer.add(nexus);
            mergeCounterArguments(
                    newConclusion,
                    multiArgSub,
                    multiArgSubB
            );

            printMatrix(nexusMatrix);
            collisionAdjustment();
            canvasControl.constructionAreaSizeCheck();
        }
    }

    /**
     * Method for merging the counter arguments of two structures when creating
     * a multiple arguments sharing the same conclusion structure
     *
     * @param parentNode
     * @param subA
     * @param subB
     * @throws IOException
     */
    private void mergeCounterArguments(
            ConclusionNode parentNode,
            ArgumentNode subA,
            ArgumentNode subB) throws IOException {
        ConclusionPaneController parentController
                = parentNode.getControl();
        List<ArgumentModel> argumentList
                = parentController.getConclusionArgumentModelList();

        // gather counter arguments
        List<CounterArgumentModel> consolidatedCounterArguments = new ArrayList<>();
        for (ArgumentModel argument : argumentList) {
            // temp reference to counter arg list for this conclusion
            List<CounterArgumentModel> currentCounterArguments
                    = argument.getConclusion().getCounterArgumentList();
            //transfer over counter arguments to consolidated list
            for (CounterArgumentModel counterArg : currentCounterArguments) {
                consolidatedCounterArguments.add(counterArg);
            }
            // clear this list. Will be populated later with consolidated list
            currentCounterArguments.clear();
        }

        if (!consolidatedCounterArguments.isEmpty()) {
            for (ArgumentModel argument : argumentList) {
                // temp reference to counter arg list for this conclusion
                List<CounterArgumentModel> currentCounterArguments
                        = argument.getConclusion().getCounterArgumentList();
                //copy consolidated list to current conclusion's counter list
                currentCounterArguments.addAll(consolidatedCounterArguments);
                //make sure that counter arguments have references to their
                //parent models
                for (CounterArgumentModel counterArg : consolidatedCounterArguments) {
                    counterArg.addToParentModelList(argument.getConclusion());
                }
            }
            /*
        create new counter arg structure for the multi-arg structure
             */
            // create the connector for the coutner arg structure
            ArgumentNode counterConnector
                    = createCounterArgumentConnection(parentNode.getView());
            parentNode.addAsChild(counterConnector);
            counterConnector.setParent(parentNode);
            canvas.getChildren().add(counterConnector.getView());

            // create shield icon
            ArgumentNode counterIcon = createCounterIcon(counterConnector);
            counterIcon.setParent(counterConnector);
            counterConnector.addAsChild(counterIcon);
            canvas.getChildren().add(counterIcon.getView());
            // add new counter icon to matrix
            paneMatrix
                    .get(
                            paneMatrix.indexOf(
                                    findMatrixLayer(parentNode, paneMatrix)
                            )
                    )
                    .add(counterIcon);

            // create the connector between the shield and the counter arg nexus
            ArgumentNode counterSecondaryConnector
                    = createPremiseConnection(counterIcon.getView(), 0);
            counterIcon.addAsChild(counterSecondaryConnector);
            counterSecondaryConnector.setParent(counterIcon);
            canvas.getChildren().add(counterSecondaryConnector.getView());
            translateNode(counterSecondaryConnector, 60, 0);

            // create counter arg nexus
            PremiseNexusNode nexus
                    = (PremiseNexusNode) createNexus(
                            1,
                            counterSecondaryConnector.getView()
                    );
            counterSecondaryConnector.addAsChild(nexus);
            nexus.setParent(counterSecondaryConnector);
            canvas.getChildren().add(nexus.getView());
            // add new nexus to matrix
            nexusMatrix
                    .get(
                            nexusMatrix.indexOf(
                                    findMatrixLayer(
                                            findNextNexus(parentNode),
                                            nexusMatrix
                                    )
                            )
                    )
                    .add(nexus);

            int targetPaneLayerIndex
                    = paneMatrix.indexOf(
                            findMatrixLayer(parentNode, paneMatrix)
                    ) + 1;
            int targetNexusLayerIndex
                    = nexusMatrix.indexOf(
                            findMatrixLayer(
                                    findNextNexus(parentNode),
                                    paneMatrix
                            )
                    ) + 1;

            // find specific counter argument connections for mainConNode counters
            ArgumentNode counterConnectionNode = null;
            for (ArgumentNode child : subA.getChildren()) {
                if (child instanceof CounterArgumentConnectionNode) {
                    counterConnectionNode = child;
                }
            }
            if (counterConnectionNode != null) {
                // remove counter icon from matrix
                removeNodeFromMatrix(
                        paneMatrix,
                        counterConnectionNode.getChildren().get(0)
                );
                //remove nexus from matrix
                removeNodeFromMatrix(
                        nexusMatrix,
                        findNextNexus(counterConnectionNode)
                );

                ListIterator<ArgumentNode> mainConSpecificCounterConnectors
                        = findNextNexus(counterConnectionNode).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while (mainConSpecificCounterConnectors.hasNext()) {
                    ArgumentNode connector = mainConSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout(nexus.getView());
                    Point2D adjustedLayout = new Point2D(
                            layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                            layout.getY()
                    );
                    translateNode(connector,
                            adjustedLayout.getX() - connector.getView().getLayoutX(),
                            adjustedLayout.getY() - connector.getView().getLayoutY()
                    );

                    // reassigne relations
                    nexus.addAsChild(connector);
                    mainConSpecificCounterConnectors.remove();
                    connector.setParent(nexus);

                    // update matrix
                    shiftCounterArgumentInMatrix(
                            paneMatrix,
                            connector,
                            targetPaneLayerIndex
                    );
                    shiftCounterArgumentInMatrix(
                            nexusMatrix,
                            connector,
                            targetNexusLayerIndex
                    );

                    printMatrix(nexusMatrix);
                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault(nexus);
                    /*
            shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX(
                            nexus.getView().getLayoutX()
                            + (amountShrunk / 2)
                    );
                    /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
                     */
                    shiftNexusChildrenOnDetach(nexus);
                }
                //undraw old counter arg structures
                counterConnectionNode.getParent().removeChild(counterConnectionNode);
                counterConnectionNode.setParent(null);
                eraseTree(counterConnectionNode);
            }

            // find specific counter argument connections for mergeRoot counters
            ArgumentNode counterConnectionNode2 = null;
            for (ArgumentNode child : subB.getChildren()) {
                if (child instanceof CounterArgumentConnectionNode) {
                    counterConnectionNode2 = child;
                }
            }

            if (counterConnectionNode2 != null) {
                // remove counter icon from matrix
                removeNodeFromMatrix(
                        paneMatrix,
                        counterConnectionNode2.getChildren().get(0)
                );
                // remove nexus from matrix
                removeNodeFromMatrix(
                        nexusMatrix,
                        findNextNexus(counterConnectionNode2)
                );

                ListIterator<ArgumentNode> mergeRootSpecificCounterConnectors
                        = findNextNexus(counterConnectionNode2).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while (mergeRootSpecificCounterConnectors.hasNext()) {
                    ArgumentNode connector = mergeRootSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout(nexus.getView());
                    Point2D adjustedLayout = new Point2D(
                            layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                            layout.getY()
                    );
                    translateNode(connector,
                            adjustedLayout.getX() - connector.getView().getLayoutX(),
                            adjustedLayout.getY() - connector.getView().getLayoutY()
                    );

                    // reassigne relations
                    nexus.addAsChild(connector);
                    mergeRootSpecificCounterConnectors.remove();
                    connector.setParent(nexus);

                    // update matrix
                    shiftCounterArgumentInMatrix(
                            paneMatrix,
                            connector,
                            targetPaneLayerIndex
                    );
                    shiftCounterArgumentInMatrix(
                            nexusMatrix,
                            connector,
                            targetNexusLayerIndex
                    );

                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault(nexus);
                    /*
            shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX(
                            nexus.getView().getLayoutX()
                            + (amountShrunk / 2)
                    );
                    /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
                     */
                    shiftNexusChildrenOnDetach(nexus);
                }
                //undraw old counter arg structures
                counterConnectionNode2.getParent().removeChild(counterConnectionNode2);
                counterConnectionNode2.setParent(null);
                eraseTree(counterConnectionNode2);
            }
            collisionAdjustment();
        }
    }

    private void shiftCounterArgumentInMatrix(
            List<List<ArgumentNode>> matrix,
            ArgumentNode subTreeRoot,
            int targetLayerIndex) {
        List<ArgumentNode> targetLayer = matrix.get(targetLayerIndex);
        ListIterator<List<ArgumentNode>> currentLayerIT
                = matrix.listIterator(targetLayerIndex + 1);

        while (currentLayerIT.hasNext()) {
            boolean swapOccured = false;
            List<ArgumentNode> currentLayer = currentLayerIT.next();
            ListIterator<ArgumentNode> currentNodeIT
                    = currentLayer.listIterator();
            while (currentNodeIT.hasNext()) {
                ArgumentNode currentNode = currentNodeIT.next();
                if (containsNode(subTreeRoot, currentNode)) {
                    currentNodeIT.remove();
                    targetLayer.add(currentNode);
                    swapOccured = true;
                }
            }

            if (swapOccured) {
                targetLayerIndex++;
                targetLayer = matrix.get(targetLayerIndex);
            }
        }

        if (currentLayerIT.previous().isEmpty()) {
            currentLayerIT.remove();
        }
    }

    private void replaceConnectorWithMultiArgConnector(ArgumentNode conNode) {
        ArgumentNode multiArgConnector = createMultiArgConnector(
                conNode.getView()
        );
        ArgumentNode mainConNexus
                = findNextNexus(conNode);
        ArgumentNode mainConConnector
                = mainConNexus.getParent();
        multiArgConnector.setParent(conNode
        );
        ListIterator<ArgumentNode> mainConConnectorIT
                = mainConConnector.getChildren().listIterator();
        while (mainConConnectorIT.hasNext()) {
            ArgumentNode child = mainConConnectorIT.next();
            multiArgConnector.addAsChild(child);
            child.setParent(multiArgConnector);
            mainConConnectorIT.remove();
        }
        conNode.removeChild(mainConConnector);
        conNode.addAsChild(multiArgConnector);
        canvas.getChildren().remove(
                mainConConnector.getView()
        );
        canvas.getChildren().add(multiArgConnector.getView());
        translateNode(mainConNexus,
                0, 205
        );
    }

    private ArgumentNode createMultiArgConnector(Node parentView) {
        Point2D layout = getRelativeLayout(parentView);
        MultiArgConnectionNode connector
                = new MultiArgConnectionNode(layout);

        return connector;
    }

    private void mergeMatrices(
            List<ArgumentNode> targetLayer,
            List<List<ArgumentNode>> targetNexus,
            List<List<ArgumentNode>> mergeNexus
    ) {
        ListIterator<List<ArgumentNode>> layerIT
                = targetNexus.listIterator(targetNexus.indexOf(targetLayer));

        Iterator<List<ArgumentNode>> mergedTreeIt
                = mergeNexus.iterator();

        while (mergedTreeIt.hasNext()) {
            if (!layerIT.hasNext()) {
                List<ArgumentNode> newLayer = new ArrayList<>();
                for (ArgumentNode nexus : mergedTreeIt.next()) {
                    newLayer.add(nexus);
                }
                layerIT.add(newLayer);
            } else {
                targetLayer = layerIT.next();
                for (ArgumentNode nexus : mergedTreeIt.next()) {
                    targetLayer.add(nexus);
                }
            }
        }
    }

    private void updateNexusMatrixShiftForward(
            ArgumentNode parent,
            List<List<ArgumentNode>> matrix
    ) {
        ListIterator<List<ArgumentNode>> layerIT
                = matrix.listIterator(matrix.size());
        while (layerIT.hasPrevious()) {
            List<ArgumentNode> tempList = new ArrayList<>();
            ListIterator<ArgumentNode> currentLayerIT
                    = layerIT.previous().listIterator();
            while (currentLayerIT.hasNext()) {
                ArgumentNode currentNode = currentLayerIT.next();
                if (containsNode(parent, currentNode)) {
                    tempList.add(currentNode);
                    currentLayerIT.remove();
                }
            }

            if (!tempList.isEmpty()) {
                layerIT.next();
                if (!layerIT.hasNext()) {
                    layerIT.add(tempList);
                } else {
                    List<ArgumentNode> targetLayer = layerIT.next();
                    for (ArgumentNode node : tempList) {
                        targetLayer.add(node);
                    }
                }
                layerIT.previous();
                layerIT.previous();
            }

        }
    }

    public void detatchMultiArgument(
            MultiArgSubConclusionPaneController subArgControl,
            Point2D coords) {
        try {
            /*
            get reference to the sub argument that is going to be split up and
            its parent
             */
            ArgumentNode target
                    = searchForNode(root, subArgControl.getMainPane());
            ArgumentNode targetConnector = target.getParent();
            ArgumentNode targetNexus = targetConnector.getParent();
            deleteCommentPane(target);
            ConclusionNode targetSharedConclusion
                    = (ConclusionNode) targetNexus.getParent().getParent();
            ConclusionPaneController targetConclusionControl
                    = targetSharedConclusion.getControl();

            List<ArgumentNode> targetLayer
                    = findMatrixLayer(target, paneMatrix);
            /*
            Remove any shared counter arguments
             */
            List<CounterArgumentModel> counterArgs
                    = subArgControl
                            .getArgument()
                            .getConclusion()
                            .getCounterArgumentList();
            // remove conclusions model of argument being detached from any
            // counter arguments
            for (CounterArgumentModel counter : counterArgs) {
                counter.removeFromParentModelList(
                        subArgControl.getArgument().getConclusion()
                );
            }
            // remove any counter arguments
            subArgControl
                    .getArgument()
                    .getConclusion()
                    .getCounterArgumentList()
                    .clear();

            /*
            get the coordinates for where the new conclusion pane will be
            drawn
             */
            Point2D targetCoords = new Point2D(
                    target.getView().getLayoutX() - 122,
                    target.getView().getLayoutY()
            );

            /*
            remove sub arg from nexus children and shared argument list
             */
            ListIterator<ArgumentNode> childIT
                    = targetNexus.getChildren().listIterator();
            while (childIT.hasNext()) {
                ArgumentNode child = childIT.next();
                if (child.equals(targetConnector)) {
                    childIT.remove();
                }
            }
            targetConclusionControl.removeArgument(subArgControl.getArgument());
            canvas.getChildren().remove(target.getView());
            canvas.getChildren().remove(targetConnector.getView());
            removeNodeFromMatrix(paneMatrix, target);
            shrinkParentNexus(targetNexus);

            /*
            create a new argument tree to contain the conclusion side of the
            split
             */
            ArgumentViewTree newArgTree
                    = new ArgumentViewTree(canvas, canvasControl);

            /*
            make a new conclusion node and attached the branch containing the
            conclusion side of the chain node to it and draw it
             */
            ConclusionNode newConclusion
                    = createConclusionView(
                            subArgControl.getArgument(),
                            targetCoords
                    );
            newConclusion.getControl().setCertaintyController(
                    subArgControl.getCertaintyControl()
            );
            newConclusion.setArgTree(newArgTree);
            newArgTree.setRoot(newConclusion);

            ArgumentNode newConclusionConnect = createConclusionConnector(
                    newConclusion.getView()
            );
            ArgumentNode detachNexus
                    = findNextNexus(target);
            ArgumentNode detachConConnector
                    = detachNexus.getParent();
            newConclusionConnect.setParent(
                    target
            );
            translateNode(target,
                    20, 0
            );
            ListIterator<ArgumentNode> detachConConnectorIT
                    = detachConConnector.getChildren().listIterator();
            while (detachConConnectorIT.hasNext()) {
                ArgumentNode child = detachConConnectorIT.next();
                newConclusionConnect.addAsChild(child);
                child.setParent(newConclusionConnect);
                detachConConnectorIT.remove();
            }
            target.removeChild(detachConConnector);
            target.addAsChild(newConclusionConnect);
            canvas.getChildren().remove(
                    detachConConnector.getView()
            );
            System.out.println("here!!!!!");
            canvas.getChildren().add(newConclusionConnect.getView());
            translateNode(detachNexus,
                    0, -100
            );
            ListIterator<ArgumentNode> targetChildren
                    = target.getChildren().listIterator();
            while (targetChildren.hasNext()) {
                ArgumentNode child = targetChildren.next();
                newConclusion.addAsChild(child);
                child.setParent(newConclusion);
                newArgTree.changeArgTree(child);
                targetChildren.remove();
            }
            canvas.getChildren().add(newConclusion.getView());

            /*
            shift the newly made argument tree so that it's offset from the
            premise of the old tree
             */
            double transX = coords.getX() - target.getView().getLayoutX();
            double transY = coords.getY() - target.getView().getLayoutY();
            translateNode(newConclusion, transX, transY);
            for (ArgumentNode node : newConclusion.getChildren()) {
                if (node instanceof ArgumentCertaintyNode) {
                    node.getView().setLayoutX(
                            node.getView().getLayoutX() + 85
                    );
                    node.getView().setLayoutY(
                            node.getView().getLayoutY() + 105
                    );
                }/*
                if (node instanceof ArgumentSchemeLabel) {
                    node.getView().setLayoutY(node.getView().getLayoutY() + 95);
                }*/
                if (node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel) {
                    translateNode(node, 0, -100);
                }
            }

            /*
            clean up chain pane and register the new tree with the
            cinstruction area
             */
            canvas.getChildren().remove(target.getView());
            canvasControl.registerNewArgTree(newArgTree);

            /*
            update the matrices and adjust tree to accomodate new dimensions
             */
            targetLayer.add(newConclusion);
            updateMatrixOnDetach(
                    newArgTree,
                    paneMatrix,
                    newArgTree.getPaneMatrix()
            );
            updateMatrixOnDetach(
                    newArgTree,
                    nexusMatrix,
                    newArgTree.getNexusMatrix()
            );
            collisionAdjustment();

            /*
            check if we need to remove the shared conclusion structure
            i.e. if there is only 1 argument left in the structure
             */
            if (targetNexus.getChildren().size() == 1) {
                ArgumentNode multiNode = targetNexus.getParent().getParent();
                if (multiNode.equals(root)) {
                    convertToSingleArgumentConclusion(
                            root,
                            targetConclusionControl.getConclusionArgumentModel()
                    );
                } else {
                    if (multiNode instanceof ChainNode) {
                        convertToSingleArgumentChain((ChainNode) multiNode);
                    }
                }
                collisionAdjustment();

            }
        } catch (IOException ex) {
            Logger.getLogger(ArgumentViewTree.class
                    .getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void convertToSingleArgumentChain(ChainNode multiArgNode)
            throws IOException {
        MultiArgSubNode subArgumentNode
                = (MultiArgSubNode) findNextSubArgument(multiArgNode);
        List<ArgumentNode> targetLayer
                = findMatrixLayer(subArgumentNode, paneMatrix);
        /*
            get the coordinates for where the new conclusion pane will be
            drawn
         */

        ChainNode newChain = createChainViewConclusion(
                multiArgNode.getParent(),
                subArgumentNode,
                multiArgNode.getControl()
        );

        newChain.setParent(multiArgNode.getParent());
        multiArgNode.getParent().addAsChild(newChain);
        newChain.getParent().removeChild(multiArgNode);
        targetLayer.add(newChain);

        newChain.getControl().setCertaintyController(
                subArgumentNode.getControl().getCertaintyControl()
        );

        ArgumentNode newConclusionConnect = createConclusionConnector(
                subArgumentNode.getView()
        );

        ArgumentNode detachNexus
                = findNextNexus(subArgumentNode);
        ArgumentNode detachConConnector
                = detachNexus.getParent();
        newConclusionConnect.setParent(
                subArgumentNode
        );

        ListIterator<ArgumentNode> detachConConnectorIT
                = detachConConnector.getChildren().listIterator();
        while (detachConConnectorIT.hasNext()) {
            ArgumentNode child = detachConConnectorIT.next();
            newConclusionConnect.addAsChild(child);
            child.setParent(newConclusionConnect);
            detachConConnectorIT.remove();
        }
        subArgumentNode.removeChild(detachConConnector);
        subArgumentNode.addAsChild(newConclusionConnect);
        canvas.getChildren().remove(
                detachConConnector.getView()
        );
        canvas.getChildren().add(newConclusionConnect.getView());

        translateNode(detachNexus,
                0, -205
        );

        ListIterator<ArgumentNode> subArgumentChildren
                = subArgumentNode.getChildren().listIterator();
        while (subArgumentChildren.hasNext()) {
            ArgumentNode child = subArgumentChildren.next();
            newChain.addAsChild(child);
            child.setParent(newChain);
            subArgumentChildren.remove();
        }

        double transY
                = newChain.getView().getBoundsInParent().getMaxY()
                - newConclusionConnect.getView().getBoundsInParent().getMinY();
        canvas.getChildren().add(newChain.getView());
        removeNodeFromMatrix(paneMatrix, multiArgNode);
        removeNodeFromMatrix(paneMatrix, subArgumentNode);
        removeNodeFromMatrix(nexusMatrix, findNextNexus(multiArgNode));
        updateNexusMatrixShiftBack(paneMatrix, newChain);
        updateNexusMatrixShiftBack(nexusMatrix, newChain);

        ArgumentNode counterConnection
                = findChildCounterConnection(multiArgNode);
        if (counterConnection != null) {
            newChain.addAsChild(counterConnection);
            counterConnection.getParent().removeChild(counterConnection);
            counterConnection.setParent(newChain);
        }

        undrawTree(multiArgNode);

        for (ArgumentNode node : newChain.getChildren()) {
            translateNode(node, 0, transY);
            if (node instanceof ArgumentCertaintyNode) {
                node.getView().setLayoutX(node.getView().getLayoutX() + 85);
            }
            if (node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel) {
                translateNode(node, 0, -205);
            }
            node.getView().toFront();
        }
        if (counterConnection != null) {
            translateNode(counterConnection, 0, -transY);
        }
    }

    private void updateNexusMatrixShiftBack(
            List<List<ArgumentNode>> matrix,
            ArgumentNode parent
    ) {
        ListIterator<List<ArgumentNode>> layerIT = matrix.listIterator();
        while (layerIT.hasNext()) {
            List<ArgumentNode> tempList = new ArrayList<>();
            ListIterator<ArgumentNode> currentLayerIT
                    = layerIT.next().listIterator();
            while (currentLayerIT.hasNext()) {
                ArgumentNode currentNode = currentLayerIT.next();
                if (containsNode(parent, currentNode)) {
                    tempList.add(currentNode);
                    currentLayerIT.remove();
                }
            }

            if (!tempList.isEmpty()) {
                layerIT.previous();
                if (!layerIT.hasPrevious()) {
                    layerIT.add(tempList);
                } else {
                    List<ArgumentNode> targetLayer = layerIT.previous();
                    for (ArgumentNode node : tempList) {
                        targetLayer.add(node);
                    }
                    layerIT.next();
                }
                layerIT.next();
            }
        }

        List<ArgumentNode> finalLayer = layerIT.previous();
        if (finalLayer.isEmpty()) {
            layerIT.remove();
        }
    }

    private ChainNode createChainViewConclusion(
            ArgumentNode parentNode,
            MultiArgSubNode subNode,
            ChainPaneController multiControl)
            throws IOException {
        ChainPaneController chainControl = generateChainNode();
        if (multiControl.getCQFlag()) {
            chainControl.setCQFlag();
            chainControl.setConnector(multiControl.getConnector());
        }
        if (multiControl.getCounterFlag()) {
            chainControl.setCounterFlag();
            chainControl.setConnector(multiControl.getConnector());
        }
        chainControl.addConclusionArgumentModel(
                multiControl.getConclusionArgumentModel()
        );
        chainControl.addPremiseArgument(multiControl.getPremiseArgument());
        chainControl.setArgumentViewTree(this);
        chainControl.setParentControl(canvasControl);
        chainControl.setCertaintyController(
                subNode.getControl().getCertaintyControl()
        );
        chainControl.setPosition(multiControl.getPosition());

        chainControl.setPropositionModel(
                multiControl.getConclusionArgumentModel().getConclusion().getProposition()
        );

        Point2D layout = getRelativeLayout(parentNode.getView());
        Point2D adjustedLayout;
        if (chainControl.getCQFlag()) {
            adjustedLayout
                    = new Point2D(
                            (int) layout.getX()
                            + chainControl.getConnector().getWidth()
                            - 163,
                            (int) layout.getY() + 15
                    );
        } else if (chainControl.getCounterFlag()) {
            adjustedLayout
                    = new Point2D(
                            (int) layout.getX()
                            + chainControl.getConnector().getWidth(),
                            (int) layout.getY() - 145
                    );
        } else {
            adjustedLayout = new Point2D(
                    (int) (layout.getX() - PREMISE_WIDTH / 2),
                    (int) layout.getY()
            );
        }

        LayoutUtils.setChildLayout(chainControl.getMainPane(), adjustedLayout);
        return new ChainNode(chainControl.getMainPane(), chainControl);
    }

    private boolean removeNodeFromMatrix(
            List<List<ArgumentNode>> matrix,
            ArgumentNode target
    ) {
        ListIterator<List<ArgumentNode>> layerIT
                = matrix.listIterator();
        boolean targetRemoved = false;
        while (layerIT.hasNext() && targetRemoved == false) {
            List<ArgumentNode> currentLayer = layerIT.next();
            ListIterator<ArgumentNode> nodeIT
                    = currentLayer.listIterator();
            while (nodeIT.hasNext() && targetRemoved == false) {
                ArgumentNode currentNode = nodeIT.next();
                if (currentNode.equals(target)) {
                    nodeIT.remove();
                    targetRemoved = true;
                }
            }
        }
        return targetRemoved;
    }

    private void convertToSingleArgumentConclusion(
            ConclusionNode multiArgConNode,
            ArgumentModel argument
    ) throws IOException {
        MultiArgSubNode subArgumentNode
                = (MultiArgSubNode) findNextSubArgument(root);
        List<ArgumentNode> targetLayer
                = findMatrixLayer(subArgumentNode, paneMatrix);

        /*
            get the coordinates for where the new conclusion pane will be
            drawn
         */
        Point2D targetCoords = new Point2D(
                multiArgConNode.getView().getLayoutX(),
                multiArgConNode.getView().getLayoutY()
        );

        ConclusionNode newConclusion = createConclusionView(
                argument, targetCoords
        );
        targetLayer.add(newConclusion);
        newConclusion.getControl().setCertaintyController(
                subArgumentNode.getControl().getCertaintyControl()
        );

        ArgumentNode newConclusionConnect = createConclusionConnector(
                subArgumentNode.getView()
        );
        ArgumentNode detachNexus
                = findNextNexus(subArgumentNode);
        ArgumentNode detachConConnector
                = detachNexus.getParent();
        newConclusionConnect.setParent(
                subArgumentNode
        );

        ListIterator<ArgumentNode> detachConConnectorIT
                = detachConConnector.getChildren().listIterator();
        while (detachConConnectorIT.hasNext()) {
            ArgumentNode child = detachConConnectorIT.next();
            newConclusionConnect.addAsChild(child);
            child.setParent(newConclusionConnect);
            detachConConnectorIT.remove();
        }
        subArgumentNode.removeChild(detachConConnector);
        subArgumentNode.addAsChild(newConclusionConnect);
        canvas.getChildren().remove(
                detachConConnector.getView()
        );
        canvas.getChildren().add(newConclusionConnect.getView());
        translateNode(newConclusionConnect,
                0, 105
        );
        translateNode(detachNexus,
                0, -205
        );

        ListIterator<ArgumentNode> subArgumentChildren
                = subArgumentNode.getChildren().listIterator();
        while (subArgumentChildren.hasNext()) {
            ArgumentNode child = subArgumentChildren.next();
            newConclusion.addAsChild(child);
            child.setParent(newConclusion);
            subArgumentChildren.remove();
        }

        double transY
                = targetCoords.getY()
                - subArgumentNode.getView().getBoundsInParent().getMinY();
        canvas.getChildren().add(newConclusion.getView());

        removeNodeFromMatrix(paneMatrix, multiArgConNode);
        removeNodeFromMatrix(paneMatrix, subArgumentNode);
        removeNodeFromMatrix(nexusMatrix, findNextNexus(multiArgConNode));

        updateNexusMatrixShiftBack(paneMatrix, newConclusion);
        updateNexusMatrixShiftBack(nexusMatrix, newConclusion);

        ArgumentNode counterConnection
                = findChildCounterConnection(multiArgConNode);
        if (counterConnection != null) {
            newConclusion.addAsChild(counterConnection);
            counterConnection.getParent().removeChild(counterConnection);
            counterConnection.setParent(newConclusion);
        }

        undrawTree(root);
        root = newConclusion;

        for (ArgumentNode node : newConclusion.getChildren()) {
            translateNode(node, 0, transY);
            if (node instanceof ArgumentCertaintyNode) {
                node.getView().setLayoutX(node.getView().getLayoutX() + 85);
                node.getView().setLayoutY(node.getView().getLayoutY() + 105);
            }
            if (node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel) {
                translateNode(node, 0, -100);
            }
        }
        if (counterConnection != null) {
            translateNode(counterConnection, 0, -transY);
        }
    }

    private ArgumentNode findChildCounterConnection(ArgumentNode target) {
        ArgumentNode result = null;
        for (ArgumentNode child : target.getChildren()) {
            if (child instanceof CounterArgumentConnectionNode) {
                result = child;
            }
        }
        return result;
    }

    private void undrawTree(ArgumentNode node) {
        canvas.getChildren().remove(node.getView());
        for (ArgumentNode child : node.getChildren()) {
            undrawTree(child);
        }
    }

    private ArgumentNode findNextSubArgument(ArgumentNode node) {
        if (node instanceof MultiArgSubNode) {
            return node;
        }

        ArgumentNode target = null;
        for (int i = 0; target == null && i < node.getChildren().size(); i++) {
            target = findNextSubArgument(node.getChildren().get(i));
        }

        return target;
    }

    public void addSupportToArgument(String mergedTreeID,
            MultiArgConclusionPaneController multiArgControl
    ) throws IOException {
        ArgumentViewTree mergedTree = canvasControl.getArgTree(mergedTreeID);
        if (mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController) {
            addMultiConclusionSupport(mergedTree, multiArgControl);
        } else {
            addSingleConclusionSupport(mergedTree, multiArgControl);
        }

    }

    public void addSupportToArgument(
            String mergedTreeID,
            MultiArgChainPaneController multiArgControl
    ) throws IOException {
        ArgumentViewTree mergedTree = canvasControl.getArgTree(mergedTreeID);
        if (mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController) {
            addMultiConclusionSupport(mergedTree, multiArgControl);
        } else {
            addSingleConclusionSupport(mergedTree, multiArgControl);
        }

    }

    private void addMultiConclusionSupport(
            ArgumentViewTree mergedTree,
            MultiArgConclusionPaneController multiArgControl
    ) throws IOException {
        ArgumentNode target
                = searchForNode(root, multiArgControl.getMainPane());
        PremiseNexusNode targetNexus = (PremiseNexusNode) findNextNexus(target);
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetPaneMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer(target, paneMatrix)
                        )
                        + 1
                );
        List<ArgumentNode> targetNexusMatrixLayer
                = nexusMatrix.get(
                        nexusMatrix.indexOf(
                                findMatrixLayer(
                                        findNextNexus(target),
                                        nexusMatrix
                                )
                        )
                        + 1
                );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ArgumentNode mergedNexus = findNextNexus(mergedRoot);

        List<MultiArgSubNode> mergeSubNodeList = new ArrayList<>();

        ListIterator<ArgumentNode> mergedNexusIT
                = mergedNexus.getChildren().listIterator();
        while (mergedNexusIT.hasNext()) {
            ArgumentNode childNode = mergedNexusIT.next();
            MultiArgSubNode subNode = findNextSubArgNode(childNode);
            mergeSubNodeList.add(subNode);
            subNode.getControl()
                    .getArgument()
                    .setConclusion(
                            multiArgControl.getProposition()
                    );

            multiArgControl.addConclusionArgumentModel(
                    subNode.getControl().getArgument()
            );

            targetNexus.addAsChild(childNode);
            childNode.setParent(targetNexus);
            mergedNexusIT.remove();

            double amountShrunk = resizeNexusToDefault(targetNexus);
            /*
            shift node so that it is centered relative to its parent
             */
            targetNexus.getView().setLayoutX(
                    targetNexus.getView().getLayoutX()
                    + (amountShrunk / 2)
            );
            /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
             */
            shiftNexusChildrenOnDetach(targetNexus);
        }

        /*
        have to skip the first layer of the merged tree's nexus so that the 
        nexus controlling the supporting sup-arguments doesn't get copied
         */
        mergeMatrices(
                targetPaneMatrixLayer,
                paneMatrix,
                mergedTree.paneMatrix.subList(1, mergedTree.paneMatrix.size())
        );
        mergeMatrices(
                targetNexusMatrixLayer,
                nexusMatrix,
                mergedTree.nexusMatrix.subList(1, mergedTree.nexusMatrix.size())
        );

        mergeCounterArguments(
                target,
                mergedRoot,
                multiArgControl,
                mergeSubNodeList
        );

        changeArgTree(root);
        canvasControl.removeArgumentTree(mergedTree.getTreeID());
        undrawTree(mergedRoot);
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();
    }

    private void addMultiConclusionSupport(
            ArgumentViewTree mergedTree,
            MultiArgChainPaneController multiArgControl
    ) throws IOException {
        ArgumentNode target
                = searchForNode(root, multiArgControl.getMainPane());
        PremiseNexusNode targetNexus = (PremiseNexusNode) findNextNexus(target);
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetPaneMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer(target, paneMatrix)
                        )
                        + 1
                );
        List<ArgumentNode> targetNexusMatrixLayer
                = nexusMatrix.get(
                        nexusMatrix.indexOf(
                                findMatrixLayer(
                                        findNextNexus(target),
                                        nexusMatrix
                                )
                        )
                        + 1
                );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ArgumentNode mergedNexus = findNextNexus(mergedRoot);

        List<MultiArgSubNode> mergeSubNodeList = new ArrayList<>();

        ListIterator<ArgumentNode> mergedNexusIT
                = mergedNexus.getChildren().listIterator();
        while (mergedNexusIT.hasNext()) {
            ArgumentNode childNode = mergedNexusIT.next();
            MultiArgSubNode subNode = findNextSubArgNode(childNode);
            mergeSubNodeList.add(subNode);
            subNode.getControl()
                    .getArgument()
                    .setConclusion(
                            multiArgControl.getProposition()
                    );

            multiArgControl.addConclusionArgumentModel(
                    subNode.getControl().getArgument()
            );

            targetNexus.addAsChild(childNode);
            childNode.setParent(targetNexus);
            mergedNexusIT.remove();

            double amountShrunk = resizeNexusToDefault(targetNexus);
            /*
            shift node so that it is centered relative to its parent
             */
            targetNexus.getView().setLayoutX(
                    targetNexus.getView().getLayoutX()
                    + (amountShrunk / 2)
            );
            /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
             */
            shiftNexusChildrenOnDetach(targetNexus);
        }

        /*
        have to skip the first layer of the merged tree's nexus so that the 
        nexus controlling the supporting sup-arguments doesn't get copied
         */
        mergeMatrices(targetPaneMatrixLayer,
                paneMatrix,
                mergedTree.paneMatrix.subList(1, mergedTree.paneMatrix.size())
        );
        mergeMatrices(
                targetNexusMatrixLayer,
                nexusMatrix,
                mergedTree.nexusMatrix.subList(1, mergedTree.nexusMatrix.size())
        );

        mergeCounterArguments(
                target,
                mergedRoot,
                multiArgControl,
                mergeSubNodeList
        );
        changeArgTree(root);
        canvasControl.removeArgumentTree(mergedTree.getTreeID());
        undrawTree(mergedRoot);
        collisionAdjustment();
        canvasControl.constructionAreaSizeCheck();

    }

    private void mergeCounterArguments(
            ArgumentNode parentNode,
            ArgumentNode mergeNode,
            ConclusionPaneController parentController,
            List<MultiArgSubNode> subNodeList
    ) throws IOException {
        List<ArgumentModel> conclusionList
                = parentController.getConclusionArgumentModelList();
        // all sub nodes should have identical counter argument lists, so we
        // only need to check the first one
        PremiseModel firstSubNodeConclusion
                = subNodeList.get(0)
                        .getControl()
                        .getArgument()
                        .getConclusion();
        PremiseModel firstMultiArgConclusion
                = conclusionList.get(0).getConclusion();
        PremiseNexusNode nexus = null;
        if (firstMultiArgConclusion.hasCounterArgument()) {
            for (ArgumentNode node : parentNode.getChildren()) {
                if (node instanceof CounterArgumentConnectionNode) {
                    nexus = (PremiseNexusNode) findNextNexus(node);
                }
            }
        }
        if (firstSubNodeConclusion.hasCounterArgument()) {
            // create counter argumnet structure if necessary
            // again, we only need to check the first counter arg list
            if (!firstMultiArgConclusion.hasCounterArgument()) {
                /*
                create new counter arg structure for the multi-arg structure
                 */
                // create the connector for the coutner arg structure
                ArgumentNode counterConnector
                        = createCounterArgumentConnection(parentNode.getView());
                parentNode.addAsChild(counterConnector);
                counterConnector.setParent(parentNode);
                canvas.getChildren().add(counterConnector.getView());

                // create shield icon
                ArgumentNode counterIcon = createCounterIcon(counterConnector);
                counterIcon.setParent(counterConnector);
                counterConnector.addAsChild(counterIcon);
                canvas.getChildren().add(counterIcon.getView());
                // add new counter icon to matrix
                paneMatrix
                        .get(
                                paneMatrix.indexOf(
                                        findMatrixLayer(parentNode, paneMatrix)
                                )
                        )
                        .add(counterIcon);

                // create the connector between the shield and the counter arg nexus
                ArgumentNode counterSecondaryConnector
                        = createPremiseConnection(counterIcon.getView(), 0);
                counterIcon.addAsChild(counterSecondaryConnector);
                counterSecondaryConnector.setParent(counterIcon);
                canvas.getChildren().add(counterSecondaryConnector.getView());
                translateNode(counterSecondaryConnector, 60, 0);

                // create counter arg nexus
                nexus = (PremiseNexusNode) createNexus(
                        1,
                        counterSecondaryConnector.getView()
                );
                counterSecondaryConnector.addAsChild(nexus);
                nexus.setParent(counterSecondaryConnector);
                canvas.getChildren().add(nexus.getView());
                nexusMatrix
                        .get(
                                nexusMatrix.indexOf(
                                        findMatrixLayer(
                                                findNextNexus(parentNode),
                                                nexusMatrix
                                        )
                                )
                        )
                        .add(nexus);
            } else {
                // if the multiArg pane already has counter args, get reference 
                // to the nexus for them
                for (ArgumentNode node : parentNode.getChildren()) {
                    if (node instanceof CounterArgumentConnectionNode) {
                        nexus = (PremiseNexusNode) findNextNexus(node);
                    }
                }
            }

            // find specific counter argument connections for mainConNode counters
            ArgumentNode counterConnectionNode = null;
            for (ArgumentNode child : mergeNode.getChildren()) {
                if (child instanceof CounterArgumentConnectionNode) {
                    counterConnectionNode = child;
                }
            }
            ListIterator<ArgumentNode> mainConSpecificCounterConnectors
                    = findNextNexus(counterConnectionNode).getChildren().listIterator();
            //translate counter arguments and reassign parents/children
            while (mainConSpecificCounterConnectors.hasNext()) {
                ArgumentNode connector = mainConSpecificCounterConnectors.next();

                Point2D layout = getRelativeLayout(nexus.getView());
                Point2D adjustedLayout = new Point2D(
                        layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                        layout.getY()
                );
                translateNode(connector,
                        adjustedLayout.getX() - connector.getView().getLayoutX(),
                        adjustedLayout.getY() - connector.getView().getLayoutY()
                );

                // reassigne relations
                nexus.addAsChild(connector);
                mainConSpecificCounterConnectors.remove();
                connector.setParent(nexus);

                // update matrix
                //shiftCounterArgumentInMatrix(
                //connector, targetLayerIndex
                //);
                // adjust nexus size
                double amountShrunk = resizeNexusToDefault(nexus);
                /*
            shift node so that it is centered relative to its parent
                 */
                nexus.getView().setLayoutX(
                        nexus.getView().getLayoutX()
                        + (amountShrunk / 2)
                );
                /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
                 */
                shiftNexusChildrenOnDetach(nexus);
            }
        }

        // gather counter arguments
        List<CounterArgumentModel> consolidatedCounterArguments
                = new ArrayList<>();
        // becuase all conclusions should have identical counter arg lists,
        // we only consolidate the counter args for the first conclusions.
        for (CounterArgumentModel counterArg
                : firstSubNodeConclusion.getCounterArgumentList()) {
            consolidatedCounterArguments.add(counterArg);
        }
        for (CounterArgumentModel counterArg
                : firstMultiArgConclusion.getCounterArgumentList()) {
            consolidatedCounterArguments.add(counterArg);
        }
        for (ArgumentModel conclusionArg : conclusionList) {
            conclusionArg.getConclusion().getCounterArgumentList().clear();
            conclusionArg.getConclusion().getCounterArgumentList().addAll(
                    consolidatedCounterArguments
            );
        }

        // walk through all counter panes and update the parent model list to
        // include all sub args
        if (nexus != null) {
            for (ArgumentNode child : nexus.getChildren()) {
                for (ArgumentNode nexusChild : child.getChildren()) {
                    if (nexusChild instanceof CounterArgumentNode) {
                        List<PremiseModel> conModelList = new ArrayList<>();
                        for (ArgumentModel conclusionArg : conclusionList) {
                            conModelList.add(conclusionArg.getConclusion());
                        }
                        ((CounterArgumentNode) nexusChild).getControl().setParentModelList(conModelList);
                    }
                    if (nexusChild instanceof CounterPropositionNode) {
                        List<PremiseModel> conModelList = new ArrayList<>();
                        for (ArgumentModel conclusionArg : conclusionList) {
                            conModelList.add(conclusionArg.getConclusion());
                        }
                        ((CounterPropositionNode) nexusChild).getControl().setParentModelList(conModelList);
                    }
                }
            }
        }
        collisionAdjustment();
    }

    private void addSingleConclusionSupport(
            ArgumentViewTree mergedTree,
            MultiArgChainPaneController multiArgControl
    ) throws IOException {
        ArgumentNode target
                = searchForNode(root, multiArgControl.getMainPane());
        PremiseNexusNode targetNexus = (PremiseNexusNode) findNextNexus(target);
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer(target, paneMatrix)
                        )
                        + 1
                );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ConclusionPaneController mergedControl
                = mergedTree.getRoot().getControl();
        ArgumentModel argument = mergedControl.getConclusionArgumentModel();

        argument.setConclusion(multiArgControl.getProposition());
        multiArgControl.addConclusionArgumentModel(argument);
        int position = multiArgControl.getConclusionArgumentModelList().size() - 1;
        ArgumentNode connection = createMultiArgPremiseConnection(
                targetNexus.getView(),
                position
        );
        targetNexus.addAsChild(connection);
        connection.setParent(targetNexus);
        canvas.getChildren().add(connection.getView());

        MultiArgSubNode subArgumentConclusion
                = (MultiArgSubNode) createMultiArgSubView(
                        argument,
                        connection.getView(),
                        mergedControl.getCertaintyController(),
                        position
                );
        connection.addAsChild(subArgumentConclusion);
        subArgumentConclusion.setParent(connection);
        canvas.getChildren().add(subArgumentConclusion.getView());

        replaceConnectorWithMultiArgConnector(mergedRoot);

        mergedTree.translateTree(subArgumentConclusion
                .getView()
                .getBoundsInParent()
                .getMinX()
                - ((PREMISE_WIDTH - 40) / 2),
                subArgumentConclusion.getView()
                        .getBoundsInParent()
                        .getMinY()
                - (PREMISE_HEIGHT - 40)
        );
        ListIterator<ArgumentNode> mergeConChildrenIT
                = mergedTree.getRoot().getChildren().listIterator();
        while (mergeConChildrenIT.hasNext()) {
            ArgumentNode child = mergeConChildrenIT.next();
            subArgumentConclusion.addAsChild(child);
            child.setParent(subArgumentConclusion);
            mergeConChildrenIT.remove();
        }
        for (ArgumentNode node : subArgumentConclusion.getChildren()) {
            if (node instanceof ArgumentCertaintyNode) {
                node.getView().setLayoutX(node.getView().getLayoutX() - 85);
            }
            if (node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel) {
                translateNode(node, 0, 205);
            }
        }
        mergedTree.replaceInPaneMatrix(mergedTree.getRoot(), subArgumentConclusion);
        changeArgTree(root);
        canvasControl.removeArgumentTree(mergedTree.getTreeID());
        canvas.getChildren().remove(mergedRoot.getView());

        double amountShrunk = resizeNexusToDefault(targetNexus);
        /*
            shift node so that it is centered relative to its parent
         */
        targetNexus.getView().setLayoutX(
                targetNexus.getView().getLayoutX()
                + (amountShrunk / 2)
        );
        /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
         */
        shiftNexusChildrenOnDetach(targetNexus);

        mergeMatrices(targetMatrixLayer, paneMatrix, mergedTree.paneMatrix);

        mergeCounterArguments((ConclusionNode) target, subArgumentConclusion);

        collisionAdjustment();

        canvasControl.constructionAreaSizeCheck();
    }

    private MultiArgSubNode findNextSubArgNode(ArgumentNode node) {
        if (node instanceof MultiArgSubNode) {
            return (MultiArgSubNode) node;
        }

        MultiArgSubNode target = null;
        for (int i = 0; target == null && i < node.getChildren().size(); i++) {
            target = findNextSubArgNode(node.getChildren().get(i));
        }
        return target;
    }

    private void addSingleConclusionSupport(
            ArgumentViewTree mergedTree,
            MultiArgConclusionPaneController multiArgControl
    ) throws IOException {
        ArgumentNode target
                = searchForNode(root, multiArgControl.getMainPane());
        PremiseNexusNode targetNexus = (PremiseNexusNode) findNextNexus(target);
        // gets the nexus layer below the one containing the target nexus
        List<ArgumentNode> targetMatrixLayer
                = paneMatrix.get(
                        paneMatrix.indexOf(
                                findMatrixLayer(target, paneMatrix)
                        )
                        + 1
                );
        ArgumentNode mergedRoot = mergedTree.getRoot();
        ConclusionPaneController mergedControl
                = mergedTree.getRoot().getControl();
        ArgumentModel argument = mergedControl.getConclusionArgumentModel();

        multiArgControl.addConclusionArgumentModel(argument);
        int position = multiArgControl.getConclusionArgumentModelList().size() - 1;
        ArgumentNode connection = createMultiArgPremiseConnection(
                targetNexus.getView(),
                position
        );
        targetNexus.addAsChild(connection);
        connection.setParent(targetNexus);
        canvas.getChildren().add(connection.getView());

        MultiArgSubNode subArgumentConclusion
                = (MultiArgSubNode) createMultiArgSubView(
                        argument,
                        connection.getView(),
                        mergedControl.getCertaintyController(),
                        position
                );
        connection.addAsChild(subArgumentConclusion);
        subArgumentConclusion.setParent(connection);
        canvas.getChildren().add(subArgumentConclusion.getView());

        replaceConnectorWithMultiArgConnector(mergedRoot);

        mergedTree.translateTree(subArgumentConclusion
                .getView()
                .getBoundsInParent()
                .getMinX()
                - ((PREMISE_WIDTH - 40) / 2),
                subArgumentConclusion.getView()
                        .getBoundsInParent()
                        .getMinY()
                - (PREMISE_HEIGHT - 40)
        );
        ListIterator<ArgumentNode> mergeConChildrenIT
                = mergedTree.getRoot().getChildren().listIterator();
        while (mergeConChildrenIT.hasNext()) {
            ArgumentNode child = mergeConChildrenIT.next();
            subArgumentConclusion.addAsChild(child);
            child.setParent(subArgumentConclusion);
            mergeConChildrenIT.remove();
        }
        for (ArgumentNode node : subArgumentConclusion.getChildren()) {
            if (node instanceof ArgumentCertaintyNode) {
                node.getView().setLayoutX(node.getView().getLayoutX() - 85);
            }
            if (node instanceof CQConnectionNode
                    || node instanceof ArgumentSchemeLabel) {
                translateNode(node, 0, 205);
            }
        }
        mergedTree.replaceInPaneMatrix(mergedTree.getRoot(), subArgumentConclusion);

        changeArgTree(root);
        canvasControl.removeArgumentTree(mergedTree.getTreeID());
        canvas.getChildren().remove(mergedRoot.getView());

        double amountShrunk = resizeNexusToDefault(targetNexus);
        /*
            shift node so that it is centered relative to its parent
         */
        targetNexus.getView().setLayoutX(
                targetNexus.getView().getLayoutX()
                + (amountShrunk / 2)
        );
        /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
         */
        shiftNexusChildrenOnDetach(targetNexus);

        mergeMatrices(targetMatrixLayer, paneMatrix, mergedTree.paneMatrix);

        mergeCounterArguments((ConclusionNode) target, subArgumentConclusion);

        collisionAdjustment();

        canvasControl.constructionAreaSizeCheck();
    }

    private void mergeCounterArguments(
            ConclusionNode parentNode,
            MultiArgSubNode subNode
    ) throws IOException {
        ConclusionPaneController parentController
                = parentNode.getControl();
        List<ArgumentModel> argumentList
                = parentController.getConclusionArgumentModelList();
        MultiArgSubConclusionPaneController subControl
                = subNode.getControl();

        if (subControl.getArgument().getConclusion().hasCounterArgument()) {
            // gather counter arguments
            List<CounterArgumentModel> consolidatedCounterArguments = new ArrayList<>();
            for (ArgumentModel conclusionModel : argumentList) {
                // temp reference to counter arg list for this conclusion
                List<CounterArgumentModel> currentCounterArguments
                        = conclusionModel.getConclusion().getCounterArgumentList();
                //transfer over counter arguments to consolidated list
                for (CounterArgumentModel counterArg : currentCounterArguments) {
                    consolidatedCounterArguments.add(counterArg);
                }
            }
            // create counter argumnet structure if necessary
            PremiseNexusNode nexus = null;
            ArgumentNode counterConnectionNode = null;
            for (ArgumentNode child : parentNode.getChildren()) {
                if (child instanceof CounterArgumentConnectionNode) {
                    counterConnectionNode = child;
                }
            }
            if (counterConnectionNode == null) {
                /*
                create new counter arg structure for the multi-arg structure
                 */
                // create the connector for the coutner arg structure
                ArgumentNode counterConnector
                        = createCounterArgumentConnection(parentNode.getView());
                parentNode.addAsChild(counterConnector);
                counterConnector.setParent(parentNode);
                canvas.getChildren().add(counterConnector.getView());

                // create shield icon
                ArgumentNode counterIcon = createCounterIcon(counterConnector);
                counterIcon.setParent(counterConnector);
                counterConnector.addAsChild(counterIcon);
                canvas.getChildren().add(counterIcon.getView());
                // add new counter icon to matrix
                paneMatrix
                        .get(
                                paneMatrix.indexOf(
                                        findMatrixLayer(parentNode, paneMatrix)
                                )
                        )
                        .add(counterIcon);

                // create the connector between the shield and the counter arg nexus
                ArgumentNode counterSecondaryConnector
                        = createPremiseConnection(counterIcon.getView(), 0);
                counterIcon.addAsChild(counterSecondaryConnector);
                counterSecondaryConnector.setParent(counterIcon);
                canvas.getChildren().add(counterSecondaryConnector.getView());
                translateNode(counterSecondaryConnector, 60, 0);

                // create counter arg nexus
                nexus = (PremiseNexusNode) createNexus(
                        1,
                        counterSecondaryConnector.getView()
                );
                counterSecondaryConnector.addAsChild(nexus);
                nexus.setParent(counterSecondaryConnector);
                canvas.getChildren().add(nexus.getView());
            } else {
                // if the multiArg pane already has counter args, get reference 
                // to the nexus for them
                for (ArgumentNode node : parentNode.getChildren()) {
                    if (node instanceof CounterArgumentConnectionNode) {
                        nexus = (PremiseNexusNode) findNextNexus(node);
                    }
                }
            }

            int targetLayerIndex
                    = paneMatrix.indexOf(
                            findMatrixLayer(parentNode, paneMatrix)
                    )
                    + 1;
            int targetNexusLayerIndex
                    = nexusMatrix.indexOf(
                            findMatrixLayer(
                                    findNextNexus(parentNode),
                                    paneMatrix
                            )
                    ) + 1;

            // find specific counter argument connections for mainConNode counters
            ArgumentNode subCounterConnectionNode = null;
            for (ArgumentNode child : subNode.getChildren()) {
                if (child instanceof CounterArgumentConnectionNode) {
                    subCounterConnectionNode = child;
                }
            }
            if (subCounterConnectionNode != null) {
                // remove counter icon from matrix
                removeNodeFromMatrix(
                        paneMatrix,
                        subCounterConnectionNode.getChildren().get(0)
                );

                ListIterator<ArgumentNode> mainConSpecificCounterConnectors
                        = findNextNexus(subCounterConnectionNode).getChildren().listIterator();
                //translate counter arguments and reassign parents/children
                while (mainConSpecificCounterConnectors.hasNext()) {
                    ArgumentNode connector = mainConSpecificCounterConnectors.next();

                    Point2D layout = getRelativeLayout(nexus.getView());
                    Point2D adjustedLayout = new Point2D(
                            layout.getX() - nexus.getView().getBoundsInParent().getWidth() / 2,
                            layout.getY()
                    );
                    translateNode(connector,
                            adjustedLayout.getX() - connector.getView().getLayoutX(),
                            adjustedLayout.getY() - connector.getView().getLayoutY()
                    );

                    // reassigne relations
                    nexus.addAsChild(connector);
                    mainConSpecificCounterConnectors.remove();
                    connector.setParent(nexus);

                    // update matrix
                    shiftCounterArgumentInMatrix(
                            paneMatrix,
                            connector,
                            targetLayerIndex
                    );
                    shiftCounterArgumentInMatrix(
                            nexusMatrix,
                            connector,
                            targetNexusLayerIndex
                    );
                    // adjust nexus size
                    double amountShrunk = resizeNexusToDefault(nexus);
                    /*
            shift node so that it is centered relative to its parent
                     */
                    nexus.getView().setLayoutX(
                            nexus.getView().getLayoutX()
                            + (amountShrunk / 2)
                    );
                    /*
            reposition subtrees of nexus so that they are in the correct
            relative positions
                     */
                    shiftNexusChildrenOnDetach(nexus);
                }
                //undraw old counter arg structures
                subCounterConnectionNode
                        .getParent()
                        .removeChild(
                                subCounterConnectionNode
                        );
                subCounterConnectionNode.setParent(null);
                eraseTree(subCounterConnectionNode);
            }
            // remove any duplicate values
            Set<CounterArgumentModel> disposal
                    = new LinkedHashSet<>(consolidatedCounterArguments);
            consolidatedCounterArguments.clear();
            consolidatedCounterArguments.addAll(disposal);

            for (ArgumentModel argument : argumentList) {
                // temp reference to counter arg list for this conclusion
                List<CounterArgumentModel> currentCounterArguments
                        = argument.getConclusion().getCounterArgumentList();
                //copy consolidated list to current conclusion's counter list
                // clear this list. Will be populated later with consolidated list
                currentCounterArguments.clear();
                currentCounterArguments.addAll(consolidatedCounterArguments);
                //make sure that counter arguments have references to their
                //parent models
                for (CounterArgumentModel counterArg : consolidatedCounterArguments) {
                    counterArg.addToParentModelList(argument.getConclusion());
                }
            }
            collisionAdjustment();
        }
    }

    public void createMultiArgChain(String mergeTreeID,
            ChainPaneController chainControl) throws IOException {
        int numPremises = 2;
        ArgumentViewTree mergedTree = canvasControl.getArgTree(mergeTreeID);
        ConclusionNode mergeTreeRoot = mergedTree.getRoot();
        mergedTree.deleteCommentPanes();
        if (!(mergedTree.getRoot().getControl() instanceof MultiArgConclusionPaneController)) {
            ChainNode chainNode
                    = (ChainNode) searchForNode(
                            root,
                            chainControl.getMainPane()
                    );
            ArgumentNode targetMatrix = findNextNexus(chainNode);
            List<ArgumentNode> targetNexusMatrixLayer
                    = findMatrixLayer(targetMatrix, nexusMatrix);
            List<ArgumentNode> targetPaneMatrixLayer
                    = findMatrixLayer(chainNode, paneMatrix);

            ChainNode multiChain
                    = createMultiArgChainView(
                            mergeTreeRoot.getControl(),
                            chainControl
                    );

            chainNode.getParent().addAsChild(multiChain);
            multiChain.setParent(chainNode.getParent());
            multiChain.getParent().removeChild(chainNode);

            ArgumentNode connector
                    = createConclusionConnector(multiChain.getView());
            multiChain.addAsChild(connector);
            connector.setParent(multiChain);
            canvas.getChildren().add(connector.getView());

            ArgumentNode label
                    = createMultiArgLabel(multiChain.getView());
            multiChain.addAsChild(label);
            label.setParent(multiChain);
            canvas.getChildren().add(label.getView());

            ArgumentNode nexus = createNexus(numPremises, connector.getView());
            connector.addAsChild(nexus);
            nexus.setParent(connector);
            canvas.getChildren().add(nexus.getView());

            ArgumentNode premiseConnect
                    = createMultiArgPremiseConnection(nexus.getView(), 0);
            nexus.addAsChild(premiseConnect);
            premiseConnect.setParent(nexus);
            canvas.getChildren().add(premiseConnect.getView());

            ArgumentNode multiArgSub = createMultiArgSubView(
                    chainNode.getControl().getConclusionArgumentModel(),
                    premiseConnect.getView(),
                    chainNode.getControl().getCertaintyController(),
                    0
            );

            replaceConnectorWithMultiArgConnector(chainNode);

            premiseConnect.addAsChild(multiArgSub);
            multiArgSub.setParent(premiseConnect);
            canvas.getChildren().add(multiArgSub.getView());
            translateNode(chainNode,
                    multiArgSub.getView().getBoundsInParent().getMinX()
                    - chainNode.getView().getBoundsInParent().getMinX()
                    - ((PREMISE_WIDTH - 40) / 2),
                    multiArgSub.getView().getBoundsInParent().getMinY()
                    - chainNode.getView().getBoundsInParent().getMinY()
                    - (PREMISE_HEIGHT - 40)
            );
            ListIterator<ArgumentNode> mainConChildrenIT
                    = chainNode.getChildren().listIterator();
            while (mainConChildrenIT.hasNext()) {
                ArgumentNode child = mainConChildrenIT.next();
                multiArgSub.addAsChild(child);
                child.setParent(multiArgSub);
                mainConChildrenIT.remove();
            }
            for (ArgumentNode node : multiArgSub.getChildren()) {
                if (node instanceof ArgumentCertaintyNode) {
                    node.getView().setLayoutX(node.getView().getLayoutX() - 85);
                }
                if (node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel) {
                    translateNode(node, 0, 205);
                }
            }
            replaceInPaneMatrix(chainNode, multiArgSub);

            ArgumentNode premiseConnectB
                    = createMultiArgPremiseConnection(nexus.getView(), 1);
            nexus.addAsChild(premiseConnectB);
            premiseConnectB.setParent(nexus);
            canvas.getChildren().add(premiseConnectB.getView());

            ArgumentNode multiArgSubB = createMultiArgSubView(
                    mergeTreeRoot.getControl().getConclusionArgumentModel(),
                    premiseConnectB.getView(),
                    mergeTreeRoot.getControl().getCertaintyController(),
                    1
            );

            replaceConnectorWithMultiArgConnector(mergedTree.getRoot());

            premiseConnectB.addAsChild(multiArgSubB);
            multiArgSubB.setParent(premiseConnectB);
            canvas.getChildren().add(multiArgSubB.getView());
            mergedTree.translateTree(multiArgSubB.getView().getBoundsInParent().getMinX()
                    - ((PREMISE_WIDTH - 40) / 2),
                    multiArgSubB.getView().getBoundsInParent().getMinY()
                    - (PREMISE_HEIGHT - 40)
            );
            ListIterator<ArgumentNode> mergeConChildrenIT
                    = mergedTree.getRoot().getChildren().listIterator();
            while (mergeConChildrenIT.hasNext()) {
                ArgumentNode child = mergeConChildrenIT.next();
                multiArgSubB.addAsChild(child);
                child.setParent(multiArgSubB);
                mergeConChildrenIT.remove();
            }
            for (ArgumentNode node : multiArgSubB.getChildren()) {
                if (node instanceof ArgumentCertaintyNode) {
                    node.getView().setLayoutX(node.getView().getLayoutX() - 85);
                }
                if (node instanceof CQConnectionNode
                        || node instanceof ArgumentSchemeLabel) {
                    translateNode(node, 0, 205);
                }
            }
            mergedTree.replaceInPaneMatrix(mergedTree.getRoot(), multiArgSubB);
            changeArgTree(root);

            canvas.getChildren().add(multiChain.getView());
            canvas.getChildren().remove(chainNode.getView());

            canvasControl.removeArgumentTree(mergeTreeID);
            canvas.getChildren().remove(mergeTreeRoot.getView());

            mergeMatrices(
                    targetPaneMatrixLayer,
                    paneMatrix,
                    mergedTree.paneMatrix
            );
            mergeMatrices(
                    targetNexusMatrixLayer,
                    nexusMatrix,
                    mergedTree.nexusMatrix
            );
            updateNexusMatrixShiftForward(nexus, paneMatrix);
            updateNexusMatrixShiftForward(nexus, nexusMatrix);
            targetPaneMatrixLayer.add(multiChain);
            targetNexusMatrixLayer.add(nexus);

            mergeCounterArguments(
                    multiChain,
                    multiArgSub,
                    multiArgSubB
            );

            collisionAdjustment();
        }
    }

    // Collision detection and matrix operations
    //--------------------------------------------------------------------------
    /**
     * method checks the pane and nexus nodes of the argument tree. If there is
     * overlap between pane nodes on the same level, this method recurses up the
     * tree to find their shared link and grows the appropriate connector to
     * remove the overlap. It then shifts tree elements in order to their new
     * positions. If a change is made, this method is called again because any
     * changes might cause collisions with other panes(like bubble-sort).
     */
    private void collisionAdjustment() {
        boolean paneMatrixAdjusted = paneMatrixAdjustment();
        /*
        recheck tree to see if further adjustments need to be made as a result
        of other changes
         */
        if (paneMatrixAdjusted) {
            collisionAdjustment();
        } else {
            nexusMatrixAdjustment();
        }
    }

    /**
     * Method checks the pane nodes of the argument tree. If there is overlap
     * between pane nodes on the same level, the youngest common ancestor of the
     * colliding nodes is found and the tree structure is adjusted to create the
     * necessary space
     *
     * @return boolean True if any adjustments are made
     */
    private boolean paneMatrixAdjustment() {
        boolean adjustmentMade = false;
        for (List<ArgumentNode> paneLayer : paneMatrix) {
            for (ArgumentNode targetPane : paneLayer) {
                /*
                compare the positions of each pane in a layer to every other 
                pane in the layer. 
                 */
                for (ArgumentNode comparePane : paneLayer) {
                    /*
                    avoid comparingthe dimensions of a pane to itself
                     */
                    if (!targetPane.equals(comparePane)) {
                        double overlap = detectPaneOverlap(targetPane, comparePane);
                        /*
                        if there is not enought space between the panes, grow
                        their shared ancestor (nexus or connector)
                         */
                        if (overlap > 0) {
                            // find linking Node
                            ArgumentNode linkingNode
                                    = findLinkingNode(targetPane, comparePane);
                            if (linkingNode instanceof PremiseNexusNode) {
                                premiseNexusCollision(
                                        (PremiseNexusNode) linkingNode,
                                        overlap
                                );
                            } else {
                                otherCollision(
                                        linkingNode,
                                        targetPane,
                                        comparePane,
                                        overlap);
                            }
                            // note that an adjustment was made
                            adjustmentMade = true;
                        }
                    }
                }
            }
        }
        return adjustmentMade;
    }

    /**
     * Method checks the nexus nodes of the argument tree. If there is overlap
     * between pane nodes on the same level, the youngest common ancestor of the
     * colliding nodes is found and the tree structure is adjusted to create the
     * necessary space
     *
     * @return boolean True if any adjustments are made
     */
    private void nexusMatrixAdjustment() {
        boolean adjustmentMade = false;
        for (List<ArgumentNode> nexusLayer : nexusMatrix) {
            /*
            for each necus in the layer, check the other nexuses in the same
            layer
             */
            for (ArgumentNode nexus : nexusLayer) {
                for (ArgumentNode compareNexus : nexusLayer) {
                    /*
                    avoid comparingthe dimensions of a pane to itself
                     */
                    if (!nexus.equals(compareNexus)) {
                        // get the overlap between the nodes
                        double overlap
                                = detectNexusOverlap(
                                        nexus, compareNexus
                                );
                        if (overlap > 0) {
                            // find linking Node
                            ArgumentNode linkingNode
                                    = findLinkingNode(nexus, compareNexus);
                            if (linkingNode instanceof PremiseNexusNode) {
                                premiseNexusCollision(
                                        (PremiseNexusNode) linkingNode,
                                        overlap
                                );
                            } else {
                                otherCollision(
                                        linkingNode,
                                        nexus,
                                        compareNexus,
                                        overlap);
                            }
                            // note that an adjustment was made
                            adjustmentMade = true;
                        }
                    }
                }
            }
        }
        if (adjustmentMade) {
            collisionAdjustment();
        }
    }

    /**
     * helper method calculates how much space needs to be made between two
     * argument panes on the same layer. A minimum of PREMISE_WIDTH is required
     * between nexuses
     *
     * @param current ArgumentNode
     * @param compare ArgumentNode
     * @return double
     */
    private double detectPaneOverlap(
            ArgumentNode targetPane,
            ArgumentNode comparePane) {
        double targetMinX
                = targetPane
                        .getView()
                        .getBoundsInParent()
                        .getMinX();
        double targetMaxX
                = targetPane
                        .getView()
                        .getBoundsInParent()
                        .getMaxX();

        double compareMinX
                = comparePane
                        .getView()
                        .getBoundsInParent()
                        .getMinX();
        double compareMaxX
                = comparePane
                        .getView()
                        .getBoundsInParent()
                        .getMaxX();

        if ((compareMinX < (targetMaxX + PADDING)
                && compareMinX > (targetMinX - PADDING))
                || (compareMaxX > (targetMinX - PADDING)
                && compareMaxX < (targetMinX + PADDING))) {
            return Math.min(
                    Math.abs(compareMaxX - (targetMinX + PADDING)),
                    Math.abs(compareMinX - (targetMaxX + PADDING))
            );
        }
        return -1;
    }

    /**
     * helper method calculates how much space needs to be made between two
     * nexuses.
     *
     * @param targetNexus ArgumentNode
     * @param compareNexus ArgumentNode
     * @return
     */
    private double detectNexusOverlap(
            ArgumentNode targetNexus,
            ArgumentNode compareNexus) {
        double targetMinX
                = targetNexus
                        .getView()
                        .getBoundsInParent()
                        .getMinX();
        double targetMaxX
                = targetNexus
                        .getView()
                        .getBoundsInParent()
                        .getMaxX();

        double compareMinX
                = compareNexus
                        .getView()
                        .getBoundsInParent()
                        .getMinX();
        double compareMaxX
                = compareNexus
                        .getView()
                        .getBoundsInParent()
                        .getMaxX();

        if ((compareMinX < (targetMaxX + PADDING + PREMISE_WIDTH)
                && compareMinX > (targetMinX - PADDING + PREMISE_WIDTH))
                || (compareMaxX > (targetMinX - PADDING + PREMISE_WIDTH)
                && compareMaxX < (targetMaxX + PADDING + PREMISE_WIDTH))) {
            return Math.min(
                    Math.abs(
                            compareMaxX - (targetMinX + PADDING + PREMISE_WIDTH)
                    ),
                    Math.abs(
                            compareMinX - (targetMaxX + PADDING + PREMISE_WIDTH)
                    )
            );
        }
        return -1;
    }

    /**
     * Re-routes collision adjustment to correct method depending on the type of
     * nodes colliding
     *
     * @param linkingNode ArgumentNode common ancestor node
     * @param nexus ArgumentNode
     * @param compareNexus ArgumentNode
     * @param overlap double overlap between argument nodes
     */
    private void otherCollision(
            ArgumentNode linkingNode,
            ArgumentNode nexus,
            ArgumentNode compareNexus,
            double overlap) {
        for (ArgumentNode child : linkingNode.getChildren()) {
            if (child instanceof CounterArgumentConnectionNode
                    && (containsNode(child, nexus)
                    || containsNode(child, compareNexus))) {
                counterArgumentConnectionCollision(
                        (CounterArgumentConnectionNode) child,
                        overlap
                );
            } else if (child instanceof CQConnectionNode
                    && (containsNode(child, nexus)
                    || containsNode(child, compareNexus))) {
                cqConnectionCollision(
                        (CQConnectionNode) child,
                        overlap
                );
            }
        }

    }

    /**
     * Grows a CQ connector to solve a collision involving a critical question
     * structure
     *
     * @param cqConnector ArgumentNode the connector being grown
     * @param overlap double overlap of collision
     */
    private void cqConnectionCollision(
            CQConnectionNode cqConnector,
            double overlap
    ) {
        /*
         grow and move the CQ connection
         */
        cqConnector.addLength((int) overlap);
        translateNode(cqConnector, -overlap, 0);
    }

    /**
     * Grows a counter argument connector to solve a collision involving a
     * counter argument structure
     *
     * @param counterArgConnector ArgumentNode the connector being grown
     * @param overlap double overlap of collision
     */
    private void counterArgumentConnectionCollision(
            CounterArgumentConnectionNode counterArgConnector,
            double overlap) {
        /*
            grow the counter argument connection
         */
        counterArgConnector.addLength((int) overlap);
        /*
        shift the counter argument structure to align with new length
         */
        for (ArgumentNode child : counterArgConnector.getChildren()) {
            translateNode(child, overlap, 0);
        }
    }

    /**
     * Grows a ArgumentNode nexus to solve a collision not involving critical
     * questions or counter arguments
     *
     * @param sharedNexus ArgumentNode common ancestor
     * @param overlap double overlap of collision
     */
    private void premiseNexusCollision(
            PremiseNexusNode sharedNexus,
            double overlap) {
        /*
        grow and shift the ancestor nexus to accomidate the
        growth
         */
        int numChildren = sharedNexus.getChildren().size();
        sharedNexus.growWidth(overlap * (numChildren - 1));
        sharedNexus.getView().setLayoutX(
                sharedNexus.getView().getLayoutX()
                - ((overlap * (numChildren - 1)) / 2)
        );
        /*
        shift the left and right sub-trees of the
        ancestor nexus
         */
        shiftRightSidePremises(sharedNexus, overlap);
        shiftLeftSidePremises(sharedNexus, overlap);
    }

    /**
     * shifts the left children of a nexus
     *
     * @param nexus
     * @param growth
     */
    private void shiftLeftSidePremises(PremiseNexusNode nexus, double growth) {
        int numChildren = nexus.getChildren().size();
        int sideCounter = 0;
        for (int i = 0; i < numChildren / 2; i++) {
            translateNode(
                    nexus.getChildren().get(i),
                    -((growth * (numChildren - 1)) / 2)
                    + (growth * sideCounter),
                    0
            );
            sideCounter++;
        }
    }

    /**
     * shifts the right side children of a nexus
     *
     * @param nexus
     * @param growth
     */
    private void shiftRightSidePremises(PremiseNexusNode nexus, double growth) {
        int numChildren = nexus.getChildren().size();
        int sideCounter = 0;
        for (int i = numChildren; i > numChildren / 2; i--) {
            translateNode(
                    nexus.getChildren().get(i - 1),
                    ((growth * (numChildren - 1)) / 2)
                    - (growth * sideCounter),
                    0
            );
            sideCounter++;
        }
    }

    /**
     * Method to find the common ancestor of 2 ArgumentNodes
     *
     * @param a ArgumentNode
     * @param b ArgumentNode
     * @return ArgumentNode common ancestor
     */
    private ArgumentNode findLinkingNode(ArgumentNode a, ArgumentNode b) {
        List<ArgumentNode> aAncestryList = new ArrayList<>();
        ArgumentNode youngestLinkingNode = null;
        while (a != null) {
            aAncestryList.add(a);
            a = a.getParent();
        }
        while (youngestLinkingNode == null && b != null) {
            if (aAncestryList.contains(b)) {
                youngestLinkingNode = b;
            }
            b = b.getParent();
        }

        return youngestLinkingNode;
    }

    private void updateNexusMatrix(
            ArgumentNode parentPane,
            ArgumentNode counterIcon,
            ArgumentNode counterPane) {
        ListIterator<List<ArgumentNode>> matrixIt = paneMatrix.listIterator(0);
        List<ArgumentNode> targetLayer = null;
        while (targetLayer == null && matrixIt.hasNext()) {
            List<ArgumentNode> inspectedLayer = matrixIt.next();
            for (ArgumentNode pane : inspectedLayer) {
                if (pane.equals(parentPane)) {
                    targetLayer = inspectedLayer;
                }
            }
        }

        targetLayer.add(counterIcon);

        if (!matrixIt.hasNext()) {
            List<ArgumentNode> newLayer = new ArrayList<>();
            matrixIt.add(newLayer);
            matrixIt.previous();
        }
        targetLayer = matrixIt.next();
        targetLayer.add(counterPane);
    }

    private void updateAllCollisionMatricesOnDetach(
            ArgumentViewTree newArgTree
    ) {
        updateMatrixOnDetach(
                newArgTree,
                paneMatrix,
                newArgTree.getPaneMatrix()
        );
        updateMatrixOnDetach(
                newArgTree,
                nexusMatrix,
                newArgTree.getNexusMatrix()
        );
    }

    private void removeSubTreeFromMatrices(ArgumentNode target) {
        removeSubTreeFromMatrix(target, paneMatrix);
        removeSubTreeFromMatrix(target, nexusMatrix);
    }

    private void removeSubTreeFromMatrix(
            ArgumentNode target,
            List<List<ArgumentNode>> matrix
    ) {
        ListIterator<List<ArgumentNode>> layerIT
                = matrix.listIterator();
        while (layerIT.hasNext()) {
            List<ArgumentNode> currentLayer = layerIT.next();
            ListIterator<ArgumentNode> nodeIT
                    = currentLayer.listIterator();
            while (nodeIT.hasNext()) {
                ArgumentNode currentNode = nodeIT.next();
                if (containsNode(target, currentNode)) {
                    nodeIT.remove();
                    if (currentLayer.isEmpty()) {
                        layerIT.remove();
                    }
                }
            }
        }
    }

    private void printMatrix(List<List<ArgumentNode>> matrix) {
        for (int i = 0; i < matrix.size(); i++) {
            System.out.print("Layer " + i + ": ");
            for (int j = 0; j < matrix.get(i).size(); j++) {
                System.out.print(":" + matrix.get(i).get(j) + ": ");
            }
            System.out.println("");
        }
    }

    private List<ArgumentNode> findMatrixLayer(
            ArgumentNode target,
            List<List<ArgumentNode>> matrix
    ) {
        List<ArgumentNode> targetLayer = null;
        for (int i = 0; targetLayer == null && i < matrix.size(); i++) {
            for (int j = 0;
                    targetLayer == null && j < matrix.get(i).size();
                    j++) {
                if (matrix.get(i).get(j).equals(target)) {
                    targetLayer = matrix.get(i);
                }
            }
        }
        if (targetLayer != null) {
            return targetLayer;
        } else {
            targetLayer = new ArrayList<>();
            matrix.add(targetLayer);
            return targetLayer;
        }
    }

    private ArgumentNode findNextNexus(ArgumentNode node) {
        Queue<ArgumentNode> queue = new LinkedList<>();
        ArgumentNode resultNode = null;
        queue.add(node);
        while (resultNode == null && !queue.isEmpty()) {
            ArgumentNode currentNode = queue.remove();
            if (currentNode instanceof PremiseNexusNode) {
                resultNode = currentNode;
            } else {
                queue.addAll(currentNode.getChildren());
            }
        }
        return resultNode;
    }
}
